<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="IOS技术总结" />



  <meta name="keywords" content="Runloop,多线程," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="先看看关于Runloop的面试题：

Runloop和线程有什么关系?
Runloop的mode作用是什么?
以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
猜想Runloop内部是如何实现的

带着这些问题，我们系统的学习下Runloop。">
<meta property="og:type" content="article">
<meta property="og:title" content="Runloop学习笔记">
<meta property="og:url" content="http://aliang9585.github.io/2015/09/17/Runloop学习笔记/index.html">
<meta property="og:site_name" content="LYL's Blog">
<meta property="og:description" content="先看看关于Runloop的面试题：

Runloop和线程有什么关系?
Runloop的mode作用是什么?
以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
猜想Runloop内部是如何实现的

带着这些问题，我们系统的学习下Runloop。">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/runloop-2@2x.png">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/runloop.png">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/RunLoop_2.png">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/RunLoop_network.png">
<meta property="og:updated_time" content="2015-09-21T04:30:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runloop学习笔记">
<meta name="twitter:description" content="先看看关于Runloop的面试题：

Runloop和线程有什么关系?
Runloop的mode作用是什么?
以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
猜想Runloop内部是如何实现的

带着这些问题，我们系统的学习下Runloop。">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

    <title> Runloop学习笔记 // LYL's Blog </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a7a4364608485ad7bc5d2abeacd05591";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<div class="container one-column page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">LYL's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-about"></i> <br />
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Runloop学习笔记
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-17T10:02:52+08:00" content="2015-09-17">
            2015-09-17
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/Runloop/" itemprop="url" rel="index"><span itemprop="name">Runloop</span></a></span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/17/Runloop学习笔记/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/09/17/Runloop学习笔记/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>先看看关于Runloop的面试题：</p>
<ol>
<li>Runloop和线程有什么关系?</li>
<li>Runloop的mode作用是什么?</li>
<li>以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</li>
<li>猜想Runloop内部是如何实现的</li>
</ol>
<p>带着这些问题，我们系统的学习下Runloop。</p>
<a id="more"></a>
<p>不知道大家有没有想过这个问题，一个应用开始运行以后放在那里，如果不对它进行任何操作，这个应用就像静止了一样，不会自发的有任何动作发生，但是如果我们点击界面上的一个按钮，这个时候就会有对应的按钮响应事件发生。给我们的感觉就像应用一直处于随时待命的状态，在没人操作的时候它一直在休息，在让它干活的时候，它就能立刻响应。其实，这就是run loop的功劳。</p>
<h2 id="一、线程与Runloop">一、线程与Runloop</h2><h3 id="1、线程任务的类型">1、线程任务的类型</h3><p>有些线程执行的任务是一条直线，起点到终点；而另一些线程要干的活则是一个圆，不断循环，直到通过某种方式将它终止。直线线程如简单的Hello World，运行打印完,它的生命周期便结束了，像昙花一现那样；圆类型的如操作系统，一直运行直到你关机。在IOS中，圆型的线程就是通过run loop不停的循环实现的。</p>
<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> &#123;</span></span><br><span class="line">    initialize<span class="params">()</span>;</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message<span class="params">()</span>;</span><br><span class="line">        process_message<span class="params">(message)</span>;</span><br><span class="line">    &#125; while <span class="params">(message != quit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模型通常被称作 Event Loop。OSX/iOS 里叫做 RunLoop</p>
<h3 id="2、线程与run_loop的关系">2、线程与run loop的关系</h3><p>Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分，Cocoa和CoreFundation都提供了run loop对象方便配置和管理线程的run loop（以下都已Cocoa为例）。每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。</p>
<h4 id="（1）主线程的run_loop默认是启动的">（1）主线程的run loop默认是启动的</h4><p>iOS的应用程序里面，程序启动后会有一个如下的main()函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了本文开始说的为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<blockquote>
<p>UIApplicationMain</p>
<p>This function is called in the main entry point to create the application object and the application delegate and set up the event cycle.</p>
<p>Return Value</p>
<p>Even though an integer return type is specified, this function never returns. When users exits an iOS application by pressing the Home button, the application moves to the background.</p>
<p>Discussion</p>
<p>This function instantiates the application object from the principal class and instantiates the delegate (if any) from the given class and sets the delegate for the application. It also sets up the main event loop, including the application’s run loop, and begins processing events. If the application’s Info.plist file specifies a main nib file to be loaded, by including the NSMainNibFile key and a valid nib file name for the value, this function loads that nib file.</p>
<p>Despite the declared return type, this function never returns. For more information on how this function behaves, see “Core App Objects” in App Programming Guide for iOS.</p>
</blockquote>
<h4 id="（2）其它线程run_loop默认是没有启动的">（2）其它线程run loop默认是没有启动的</h4><p>如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>
<h4 id="（3）在任何一个Cocoa程序的线程中，都可以获取到当前线程的run_loop">（3）在任何一个Cocoa程序的线程中，都可以获取到当前线程的run loop</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> *runloop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br></pre></td></tr></table></figure>
<p>线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h3 id="3、关于run_loop的几点说明">3、关于run loop的几点说明</h3><h4 id="（1）Cocoa中的NSRunLoop类并不是线程安全的">（1）Cocoa中的NSRunLoop类并不是线程安全的</h4><p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>我们不能再一个线程中去操作另外一个线程的run loop对象，那很可能会造成意想不到的后果。不过幸运的是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的run loop完全可以混合使用。Cocoa中的NSRunLoop类可以通过实例方法：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">CFRunLoopRef</span>)</span>getCFRunLoop<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>获取对应的CFRunLoopRef类，来达到线程安全的目的</p>
<p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="external">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>
<h4 id="（2）run_loop的管理并不完全是自动的">（2）run loop的管理并不完全是自动的</h4><p>我们仍必须设计线程代码以在适当的时候启动run loop并正确响应输入事件，当然前提是线程中需要用到run loop。而且，我们还需要使用while/for语句来驱动run loop能够循环运行，下面的代码就成功驱动了一个run loop：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL isRunning = NO;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">    isRunning = <span class="string">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopModebeforeDate:[NSDate distantFuture]]</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (isRunning);</span><br></pre></td></tr></table></figure>
<h4 id="（3）run_loop同时也负责autorelease_pool的创建和释放">（3）run loop同时也负责autorelease pool的创建和释放</h4><p>在使用手动的内存管理方式的项目中，会经常用到很多自动释放的对象，如果这些对象不能够被即时释放掉，会造成内存占用量急剧增大。Run loop就为我们做了这样的工作，每当一个运行循环结束的时候，它都会释放一次autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。</p>
<h4 id="（4）run_loop_的优点">（4）run loop 的优点</h4><p>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。如果仅仅是想实现这个功能，你可能会想一个简单的while循环不就可以实现了吗，用得着费老大劲来做个那么复杂的机制？显然，苹果的架构设计师不是吃干饭的，你想到的他们早就想过了。</p>
<p>首先，NSRunLoop是一种更加高明的消息处理模式，他就高明在对消息处理过程进行了更好的抽象和封装，这样才能是的你不用处理一些很琐碎很低层次的具体消息的处理，在NSRunLoop中每一个消息就被打包在input source或者是timer source（见后文）中了。</p>
<p>其次，也是很重要的一点，使用run loop可以使你的线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。</p>
<h2 id="二、RunLoop_对外的接口">二、RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="http://7xkfcm.com1.z0.glb.clouddn.com/runloop-2@2x.png" alt="image description"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<h3 id="CFRunLoopSourceRef">CFRunLoopSourceRef</h3><p>是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ol>
<li>Source0：非基于端口的源， 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1：基于端口的源， 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ol>
<h3 id="CFRunLoopTimerRef">CFRunLoopTimerRef</h3><p>是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<h3 id="CFRunLoopObserverRef">CFRunLoopObserverRef</h3><p>是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span>         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span>          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="三、输入事件来源">三、输入事件来源</h2><p>Run loop接收输入事件来自两种不同的来源：输入源（input source）和定时源（timer source）。两种源都使用程序的某一特定的处理例程来处理到达的事件。图-1显示了run loop的概念结构以及各种源。</p>
<p>需要说明的是，当你创建输入源，你需要将其分配给run loop中的一个或多个模式（什么是模式，下文将会讲到）。模式只会在特定事件影响监听的源。大多数情况下，run loop运行在默认模式下，但是你也可以使其运行在自定义模式。若某一源在当前模式下不被监听，那么任何其生成的消息只在run loop运行在其关联的模式下才会被传递。</p>
<p>图-1  Runloop的结构和输入源类型</p>
<p><img src="http://7xkfcm.com1.z0.glb.clouddn.com/runloop.png" alt="image description"></p>
<p>上图显示了线程的输入源</p>
<ol>
<li>基于端口的输入源（Port Sources）</li>
<li>自定义输入源（Custom Sources）</li>
<li>Cocoa执行Selector的源（”performSelector…方法” Sources）</li>
<li>定时源（Timer Sources ）</li>
</ol>
<p>线程针对上面不同的输入源，有不同的处理机制</p>
<ol>
<li>handlePort－－－处理基于端口的输入源</li>
<li>customSrc－－－处理用户自定义输入源</li>
<li>mySelector－－－处理Selector的源</li>
<li>timerFired－－－处理定时源</li>
</ol>
<p>线程除了处理输入源，Run Loops也会生成关于Run Loop行为的通知（notification）。Run Loop观察者（Run-Loop Observers）可以收到这些通知，并在线程上面使用他们来作额为的处理</p>
<h3 id="1、输入源（input_source）">1、输入源（input source）</h3><p>传递异步事件，通常消息来自于其他线程或程序。输入源传递异步消息给相应的处理例程，并调用runUntilDate:方法来退出(在线程里面相关的NSRunLoop对象调用)。</p>
<h4 id="（1）基于端口的输入源">（1）基于端口的输入源</h4><p>基于端口的输入源由内核自动发送。</p>
<p>Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建的基于端口的源。例如:</p>
<p>在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用NSPort的方法把该端口添加到run loop。端口对象会自己处理创建和配置输入源。</p>
<p>在Core Foundation，你必须人工创建端口和它的run loop源。我们可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。下面的例子展示了如何创建一个基于端口的输入源，将其添加到run loop并启动：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原文代码:基于端口的输入源-----------------------------</span></span><br><span class="line"><span class="built_in">BOOL</span> pageStillLoading;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDataRef</span> myCallbackFunc(<span class="built_in">CFMessagePortRef</span> local,SInt32 msgid,<span class="built_in">CFDataRef</span> cfData, <span class="keyword">void</span>*info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> createPortSource()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFMessagePortRef</span> port = <span class="built_in">CFMessagePortCreateLocal</span>(k<span class="built_in">CFAllocatorDefault</span>,<span class="built_in">CFSTR</span>(<span class="string">"com.someport"</span>),myCallbackFunc, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(k<span class="built_in">CFAllocatorDefault</span>, port,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source,k<span class="built_in">CFRunLoopCommonModes</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pageStillLoading) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">        </span><br><span class="line">        [pool release];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source,k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）自定义输入源">（2）自定义输入源</h4><p>自定义的输入源需要人工从其他线程发送。</p>
<p>为了创建自定义输入源，必须使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数来创建。你可以使用回调函数来配置自定义输入源。Core Fundation会在配置源的不同地方调用回调函数，处理输入事件，在源从run loop移除的时候清理它。</p>
<p>除了定义在事件到达时自定义输入源的行为，你也必须定义消息传递机制。源的这部分运行在单独的线程里面，并负责在数据等待处理的时候传递数据给源并通知它处理数据。消息传递机制的定义取决于你，但最好不要过于复杂。创建并启动自定义输入源的示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原文代码:自定义输入源-----------------------------</span></span><br><span class="line"><span class="keyword">void</span> createCustomSource()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>,<span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source =<span class="built_in">CFRunLoopSourceCreate</span>(k<span class="built_in">CFAllocatorDefault</span>,<span class="number">0</span>, &amp;context);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source,k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pageStillLoading) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">        </span><br><span class="line">        [pool release];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source,k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：原文中关于输入源的这两个例子并不完整。我们来完善一下，CFMessagePort部分可以参考<a href="iOS进程间通信之CFMessagePort">《iOS进程间通信之CFMessagePort》</a>：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define LOCAL_MACH_PORT_NAME   <span class="title">"com.wangzz.demo"</span></span></span><br><span class="line"><span class="preprocessor">#define MACH_PORT_REMOTE       <span class="title">"com.wangzz.demo"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CFMessagePort端口消息的接收者需要实现以下功能：</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark step 2 实现回调方法</span></span><br><span class="line"><span class="comment">//CFMessagePortCallBack 各个参数的含义为：</span></span><br><span class="line"><span class="comment">//CFMessagePortRef local : 当前接收消息的CFMessagePortRef对象。</span></span><br><span class="line"><span class="comment">//SInt32 msgid : 这个字段非常有用，用于标识消息。如果通信双方进程约定号每个msgid对应的数据结构，即可实现较为复杂的通信。</span></span><br><span class="line"><span class="comment">//CFDataRef data : 通信的真正数据部分。</span></span><br><span class="line"><span class="comment">//void *info : 为使用CFMessagePortCreateLocal方法创建port端口时指定的CFMessagePortContext对象的info字段，通常为空。</span></span><br><span class="line"><span class="comment">//该回调方法可以返回一个CFDataRef类型的数据给port消息的发送者，以实现有效的双方通信，这一点也非常重要。</span></span><br><span class="line"><span class="built_in">CFDataRef</span> onRecvMessageCallBack(<span class="built_in">CFMessagePortRef</span> local,SInt32 msgid,<span class="built_in">CFDataRef</span> cfData, <span class="keyword">void</span>*info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"onRecvMessageCallBack is called"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *strData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (cfData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">UInt8</span>  * recvedMsg = <span class="built_in">CFDataGetBytePtr</span>(cfData);</span><br><span class="line">        strData = [<span class="built_in">NSString</span> stringWithCString:(<span class="keyword">char</span> *)recvedMsg encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         实现数据解析操作</span><br><span class="line">         **/</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"receive message:%@"</span>,strData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了测试，生成返回数据</span></span><br><span class="line">    <span class="built_in">NSString</span> *returnString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"i have receive:%@"</span>,strData];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cStr = [returnString UTF8String];</span><br><span class="line">    <span class="built_in">NSUInteger</span> ulen = [returnString lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">CFDataRef</span> sgReturn = <span class="built_in">CFDataCreate</span>(<span class="literal">NULL</span>, (<span class="built_in">UInt8</span> *)cStr, ulen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sgReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark step 1 注册监听</span></span><br><span class="line"><span class="comment">//消息接收者需要通过以下方式注册消息监听：</span></span><br><span class="line"><span class="built_in">CFMessagePortRef</span> mMsgPortListenner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> startListenning()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != mMsgPortListenner &amp;&amp; <span class="built_in">CFMessagePortIsValid</span>(mMsgPortListenner))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CFMessagePortInvalidate</span>(mMsgPortListenner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过CFMessagePortCreateLocal可以创建一个本地CFMessagePortRef对象</span></span><br><span class="line">    <span class="comment">//CFMessagePort对象是靠一个字符串来唯一标识的，这一点非常重要，在这里字符串是由宏LOCAL_MACH_PORT_NAME定义的；</span></span><br><span class="line">    <span class="comment">//创建CFMessagePort对象的同时设置了端口源事件的回调函数onRecvMessageCallBack，用于处理端口源事件；</span></span><br><span class="line">    mMsgPortListenner = <span class="built_in">CFMessagePortCreateLocal</span>(k<span class="built_in">CFAllocatorDefault</span>,<span class="built_in">CFSTR</span>(LO<span class="built_in">CAL_MACH_PORT_NAME</span>),onRecvMessageCallBack, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将创建的对象作为输入源添加到Runloop中，从而实现对端口源事件的监听，当Runloop收到对应的端口源事件时，会调用上一步中指定的回调方法；</span></span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(k<span class="built_in">CFAllocatorDefault</span>, mMsgPortListenner, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, k<span class="built_in">CFRunLoopCommonModes</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start listenning"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark step 3 取消端口监听</span></span><br><span class="line"><span class="comment">//CFMessagePortInvalidate会停止port消息的发送和接收操作，而只有调用了CFRelease，CFMessagePortRef对象才真正的被释放掉。</span></span><br><span class="line"><span class="keyword">void</span> endLisenning()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFMessagePortInvalidate</span>(mMsgPortListenner);</span><br><span class="line">    <span class="built_in">CFRelease</span>(mMsgPortListenner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark step 4 消息发送者,应该在另一个进程，写这里为了测试方便</span></span><br><span class="line"><span class="built_in">NSString</span>* sendMessageToDameonWithMsgInfoMsgid(<span class="keyword">id</span> msgInfo, <span class="keyword">int</span> msgid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 生成Remote port</span></span><br><span class="line">    <span class="built_in">CFMessagePortRef</span> bRemote = <span class="built_in">CFMessagePortCreateRemote</span>(k<span class="built_in">CFAllocatorDefault</span>, <span class="built_in">CFSTR</span>(MACH_PORT_REMOTE));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> == bRemote) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bRemote create failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建发送数据（string）</span></span><br><span class="line">    <span class="built_in">NSString</span>    *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,msgInfo];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"send msg is :%@"</span>,msg);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = [msg UTF8String];</span><br><span class="line">    <span class="built_in">CFDataRef</span> data,recvData = <span class="literal">nil</span>;</span><br><span class="line">    data = <span class="built_in">CFDataCreate</span>(<span class="literal">NULL</span>, (<span class="built_in">UInt8</span> *)message, strlen(message));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行发送操作</span></span><br><span class="line">    <span class="built_in">CFMessagePortSendRequest</span>(bRemote, msgid, data, <span class="number">0</span>, <span class="number">100</span> , k<span class="built_in">CFRunLoopDefaultMode</span>, &amp;recvData);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> == recvData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"recvData date is nil."</span>);</span><br><span class="line">        <span class="built_in">CFRelease</span>(data);</span><br><span class="line">        <span class="built_in">CFMessagePortInvalidate</span>(bRemote);</span><br><span class="line">        <span class="built_in">CFRelease</span>(bRemote);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析返回数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">UInt8</span>  * recvedMsg = <span class="built_in">CFDataGetBytePtr</span>(recvData);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> == recvedMsg) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"receive date err."</span>);</span><br><span class="line">        <span class="built_in">CFRelease</span>(data);</span><br><span class="line">        <span class="built_in">CFMessagePortInvalidate</span>(bRemote);</span><br><span class="line">        <span class="built_in">CFRelease</span>(bRemote);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span>    *strMsg = [<span class="built_in">NSString</span> stringWithCString:(<span class="keyword">char</span> *)recvedMsg encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strMsg);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(data);</span><br><span class="line">    <span class="built_in">CFMessagePortInvalidate</span>(bRemote);</span><br><span class="line">    <span class="built_in">CFRelease</span>(bRemote);</span><br><span class="line">    <span class="built_in">CFRelease</span>(recvData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> strMsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        startListenning();</span><br><span class="line">        </span><br><span class="line">        sendMessageToDameonWithMsgInfoMsgid(<span class="string">@"abc"</span>,  <span class="number">111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）Cocoa上的Selector源">（3）Cocoa上的Selector源</h4><p>除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector方法。和基于端口的源一样，执行selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个selector执行完后会自动从run loop里面移除。</p>
<p>当在其他线程上面执行selector时，目标线程须有一个活动的run loop。对于你创建的线程，这意味着线程在你显式的启动run loop之前是不会执行selector方法的，而是一直处于休眠状态。</p>
<p>NSObject类提供了类似如下的selector方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(id)</span>argwaitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait modes:<span class="params">(<span class="variable">NSArray</span> *)</span>array;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、定时源（timer_source）">2、定时源（timer source）</h3><p>定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程，不会立即退出run loop。</p>
<p>需要注意的是，尽管定时器可以产生基于时间的通知，但它并不是实时机制。和输入源一样，定时器也和你的run loop的特定模式相关。如果定时器所在的模式当前未被run loop监视，那么定时器将不会开始直到run loop运行在相应的模式下。类似的，如果定时器在run loop处理某一事件期间开始，定时器会一直等待直到下次run loop开始相应的处理程序。如果run loop不再运行，那定时器也将永远不启动。</p>
<p>创建定时器源有两种方法，</p>
<p>方法一：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">4.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">backgroundThreadFire:</span>) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">    </span><br><span class="line">    [[NSRunLoop currentRunLoop] <span class="string">addTimer:</span><span class="string">timerforMode:</span>NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">10</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">backgroundThreadFire:</span>) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure>
<h2 id="四、RunLoop观察者">四、RunLoop观察者</h2><p>源是在合适的同步或异步事件发生时触发，而run loop观察者则是在run loop本身运行的特定时候触发。你可以使用run loop观察者来为处理某一特定事件或是进入休眠的线程做准备。你可以将run loop观察者和以下事件关联：</p>
<ol>
<li>Runloop入口</li>
<li>Runloop何时处理一个定时器</li>
<li>Runloop何时处理一个输入源</li>
<li>Runloop何时进入睡眠状态</li>
<li>Runloop何时被唤醒，但在唤醒之前要处理的事件</li>
<li>Runloop终止</li>
</ol>
<p>和定时器类似，在创建的时候你可以指定run loop观察者可以只用一次或循环使用。若只用一次，那么在它启动后，会把它自己从run loop里面移除，而循环的观察者则不会。定义观察者并把它添加到run loop，只能使用Core Fundation。下面的例子演示了如何创建run loop的观察者：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addObserverToCurrentRunloop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个带有观测者的线程加载程序</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserverToCurrentRunloop &#123;</span><br><span class="line">    <span class="comment">// 获得当前thread的Run loop</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span> *myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    <span class="comment">// 设置Run Loop observer的运行环境</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    CFRunLoopObserverRef CFRunLoopObserverCreate ( 创建Run loop observer对象</span></span><br><span class="line"><span class="comment">//      CFAllocatorRef allocator, 用于分配该observer对象的内存</span></span><br><span class="line"><span class="comment">//      CFOptionFlags activities, 用以设置该observer所要关注的的事件，详见回调函数myRunLoopObserver中注释</span></span><br><span class="line"><span class="comment">//      Boolean repeats, 标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行</span></span><br><span class="line"><span class="comment">//      CFIndex order, 设置该observer的优先级</span></span><br><span class="line"><span class="comment">//      CFRunLoopObserverCallBack callout, 设置该observer的回调函数</span></span><br><span class="line"><span class="comment">//      CFRunLoopObserverContext *context 用于设置该observer的运行环境</span></span><br><span class="line"><span class="comment">//    );</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(k<span class="built_in">CFAllocatorDefault</span>, k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, &amp;myRunLoopObserver, &amp;context);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(observer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将Cocoa的NSRunLoop类型转换程Core Foundation的CFRunLoopRef类型</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> cfRunLoop = [myRunLoop get<span class="built_in">CFRunLoop</span>];</span><br><span class="line">        <span class="comment">// 将新建的observer加入到当前的thread的run loop</span></span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(cfRunLoop, observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Creates and returns a new NSTimer object and schedules it on the current run loop in the default mode</span></span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSInteger</span> loopCount = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动当前thread的run loop直到所指定的时间到达，在run loop运行时，run loop会处理所有来自与该run loop联系的input sources的数据</span></span><br><span class="line">        <span class="comment">// 对于本例与当前run loop联系的input source只有Timer类型的source</span></span><br><span class="line">        <span class="comment">// 该Timer每隔3.0秒发送触发时间给run loop，run loop检测到该事件时会调用相应的处理方法（doFireTimer:）</span></span><br><span class="line">        <span class="comment">// 由于在run loop添加了observer，且设置observer对所有的run loop行为感兴趣</span></span><br><span class="line">        <span class="comment">// 当调用runUntilDate方法时，observer检测到run loop启动并进入循环，observer会调用其回调函数，第二个参数所传递的行为时kCFRunLoopEntry</span></span><br><span class="line">        <span class="comment">// observer检测到run loop的其他行为并调用回调函数的操作与上面的描述相类似</span></span><br><span class="line">        </span><br><span class="line">        [myRunLoop runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>]];</span><br><span class="line">        <span class="comment">// 当run loop的运行时间到达时，会退出当前的run loop，observer同样会检测到run loop的退出行为，并调用其回调函数，第二个参数传递的行为是kCFRunLoopExit.</span></span><br><span class="line">        --loopCount;</span><br><span class="line">    &#125;<span class="keyword">while</span>(loopCount);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//＝＝＝observer的回调函数：</span></span><br><span class="line"><span class="keyword">void</span> myRunLoopObserver(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(activity)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// The entrance of run loop, before entering the event processing loop.</span></span><br><span class="line">            <span class="comment">// This activity occurs once for each call to CFRunLoopRun / CFRunLoopRunInMode</span></span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopEntry</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1、run loop entry"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// Inside the event processing loop before any timers are processed</span></span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeTimers</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2、run loop before timers"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// Inside the event processing loop before any sources are processed</span></span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeSources</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3、run loop before sources"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// Inside the event processing loop before the run loop sleeps, waiting for a source or timer to fire</span></span><br><span class="line">            <span class="comment">// This activity does not occur if CFRunLoopRunInMode is called with a timeout of o seconds</span></span><br><span class="line">            <span class="comment">// It also does not occur in a particular iteration of the event processing loop if a version 0 source fires</span></span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeWaiting</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4、run loop before waiting"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// Inside the event processing loop after the run loop wakes up, but before processing the event that woke it up</span></span><br><span class="line">            <span class="comment">// This activity occurs only if the run loop did in fact go to sleep during the current loop</span></span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopAfterWaiting</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"5、run loop after waiting"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// The exit of the run loop, after exiting the event processing loop</span></span><br><span class="line">            <span class="comment">// This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode</span></span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopExit</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"6、run loop exit"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             A combination of all the preceding stages</span><br><span class="line">             case kCFRunLoopAllActivities:</span><br><span class="line">             break;</span><br><span class="line">             */</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doFireTimer:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------doFireTimer-------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、RunLoop_的_Mode">五、RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set&lt;CFRunLoopSourceRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set&lt;CFRunLoopSourceRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array&lt;CFRunLoopObserverRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array&lt;CFRunLoopTimerRef&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set&lt;CFStringRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set&lt;CFRunLoopModeRef&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure>
<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="六、RunLoop的事件队列">六、RunLoop的事件队列</h2><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p>
<p><img src="http://7xkfcm.com1.z0.glb.clouddn.com/RunLoop_2.png" alt="image description"></p>
<p>每次运行run loop，你线程的run loop对会自动处理之前未处理的消息，并通知相关的观察者。具体的顺序如下：</p>
<ol>
<li>通知观察者：即将进入loop</li>
<li>通知观察者：将要处理Timer</li>
<li>通知观察者：将要处理非基于端口的源（Source0）</li>
<li>处理非基于端口的源（Source0）</li>
<li>如果基于端口的源（Source1）准备好并处于等待状态，立即启动；并进入步骤9。</li>
<li>通知观察者：线程即将进入休眠</li>
<li>将线程置于休眠状态直到任一下面的事件发生：<ul>
<li>某一事件到达基于端口的源</li>
<li>定时器启动</li>
<li>run loop设置的时间已经超时</li>
<li>run loop被显式唤醒</li>
</ul>
</li>
<li>通知观察者：线程刚被唤醒。</li>
<li>处理唤醒时收到的消息<ul>
<li>如果用户定义的定时器启动，处理定时器事件并重启run loop。进入步骤2</li>
<li>如果输入源启动，传递相应的消息</li>
<li>如果run loop被显式唤醒而且时间还没超时，重启run loop。进入步骤2</li>
</ul>
</li>
<li>通知观察者：即将退出loop。</li>
</ol>
<p>因为定时器和输入源的观察者是在相应的事件发生之前传递消息，所以通知的时间和实际事件发生的时间之间可能存在误差。如果需要精确时间控制，你可以使用休眠和唤醒通知来帮助你校对实际发生事件的时间。</p>
<p>因为当你运行run loop时定时器和其它周期性事件经常需要被传递，撤销run loop也会终止消息传递。典型的例子就是鼠标路径追踪。因为你的代码直接获取到消息而不是经由程序传递，因此活跃的定时器不会开始直到鼠标追踪结束并将控制权交给程序。</p>
<p>Run loop可以由run loop对象显式唤醒。其它消息也可以唤醒run loop。例如，添加新的非基于端口的源会唤醒run loop从而可以立即处理输入源而不需要等待其他事件发生后再处理。</p>
<p>从这个事件队列中可以看出：</p>
<p>①如果是事件到达，消息会被传递给相应的处理程序来处理， runloop处理完当次事件后，run loop会退出，而不管之前预定的时间到了没有。你可以重新启动run loop来等待下一事件。</p>
<p>②如果线程中有需要处理的源，但是响应的事件没有到来的时候，线程就会休眠等待相应事件的发生。这就是为什么run loop可以做到让线程有工作的时候忙于工作，而没工作的时候处于休眠状态。</p>
<h2 id="七、什么时候使用run_loop">七、什么时候使用run loop</h2><p>仅当在为你的程序创建辅助线程的时候，你才需要显式运行一个run loop。Run loop是程序主线程基础设施的关键部分。所以，Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动run loop。IOS程序中UIApplication的run方法（或Mac OS X中的NSApplication）作为程序启动步骤的一部分，它在程序正常启动的时候就会启动程序的主循环。类似的，RunApplicationEventLoop函数为Carbon程序启动主循环。如果你使用xcode提供的模板创建你的程序，那你永远不需要自己去显式的调用这些例程。</p>
<p>对于辅助线程，你需要判断一个run loop是否是必须的。如果是必须的，那么你要自己配置并启动它。你不需要在任何情况下都去启动一个线程的run loop。比如，你使用线程来处理一个预先定义的长时间运行的任务时，你应该避免启动run loop。Run loop在你要和线程有更多的交互时才需要，比如以下情况：</p>
<ol>
<li>使用端口或自定义输入源来和其他线程通信</li>
<li>使用线程的定时器</li>
<li>Cocoa中使用任何performSelector…的方法</li>
<li>使线程周期性工作</li>
</ol>
<p>如果你决定在程序中使用run loop，那么它的配置和启动都很简单。和所有线程编程一样，你需要计划好在辅助线程退出线程的情形。让线程自然退出往往比强制关闭它更好。</p>
<h2 id="八、苹果用_RunLoop_实现的功能">八、苹果用 RunLoop 实现的功能</h2><h3 id="1、_App_启动后_RunLoop_的状态">1、 App 启动后 RunLoop 的状态</h3><p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<h3 id="2、AutoreleasePool">2、AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="3、事件响应">3、事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="4、手势识别">4、手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="5、界面更新">5、界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="6、定时器">6、定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p>
<h3 id="7、PerformSelecter">7、PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="8、关于GCD">8、关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch<em>async(dispatch<em>get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</em></em>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="9、关于网络请求">9、关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFSocket</span></span><br><span class="line"><span class="built_in">CFNetwork</span>       -&gt;ASIHttpRequest</span><br><span class="line"><span class="built_in">NSURLConnection</span> -&gt;AFNetworking</span><br><span class="line"><span class="built_in">NSURLSession</span>    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>
<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p><img src="http://7xkfcm.com1.z0.glb.clouddn.com/RunLoop_network.png" alt="image description"></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<blockquote>
<p>参考：</p>
<p><a href="http://m.blog.csdn.net/blog/womendeaiwoming/44968501" target="_blank" rel="external">NSRunLoop基本原理</a></p>
<p><a href="http://blog.csdn.net/ztp800201/article/details/9240913" target="_blank" rel="external">Objective-C之run loop详解</a></p>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
<p><a href="http://blog.chinaunix.net/uid-24862988-id-3408565.html" target="_blank" rel="external"> iOS多线程开发（三）－－－Run Loop（一）</a></p>
</blockquote>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Runloop/" rel="tag">#Runloop</a>
          
            <a href="/tags/多线程/" rel="tag">#多线程</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/08/22/自定义UICollectionViewLayout（三）/" rel="next">自定义UICollectionViewLayout（三）Custom Layouts - A Worked Example翻译</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div id="disqus_thread">
                    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/avatar.png" alt="YL" itemprop="image"/>
          <p class="site-author-name" itemprop="name">YL</p>
        </div>
        <p class="site-description motion-element" itemprop="description">IOS技术总结</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://aliang9585.github.io" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/ytlvy" target="_blank">Twitter</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://nshipster.com" target="_blank">NSHipster</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.mikeash.com/pyblog" target="_blank">NSBlog</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.objc.io" target="_blank">objcio</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.raywenderlich.com" target="_blank">raywenderlich</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、线程与Runloop"><span class="nav-number">1.</span> <span class="nav-text">一、线程与Runloop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、线程任务的类型"><span class="nav-number">1.1.</span> <span class="nav-text">1、线程任务的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、线程与run_loop的关系"><span class="nav-number">1.2.</span> <span class="nav-text">2、线程与run loop的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）主线程的run_loop默认是启动的"><span class="nav-number">1.2.1.</span> <span class="nav-text">（1）主线程的run loop默认是启动的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）其它线程run_loop默认是没有启动的"><span class="nav-number">1.2.2.</span> <span class="nav-text">（2）其它线程run loop默认是没有启动的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）在任何一个Cocoa程序的线程中，都可以获取到当前线程的run_loop"><span class="nav-number">1.2.3.</span> <span class="nav-text">（3）在任何一个Cocoa程序的线程中，都可以获取到当前线程的run loop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、关于run_loop的几点说明"><span class="nav-number">1.3.</span> <span class="nav-text">3、关于run loop的几点说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）Cocoa中的NSRunLoop类并不是线程安全的"><span class="nav-number">1.3.1.</span> <span class="nav-text">（1）Cocoa中的NSRunLoop类并不是线程安全的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）run_loop的管理并不完全是自动的"><span class="nav-number">1.3.2.</span> <span class="nav-text">（2）run loop的管理并不完全是自动的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）run_loop同时也负责autorelease_pool的创建和释放"><span class="nav-number">1.3.3.</span> <span class="nav-text">（3）run loop同时也负责autorelease pool的创建和释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）run_loop_的优点"><span class="nav-number">1.3.4.</span> <span class="nav-text">（4）run loop 的优点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、RunLoop_对外的接口"><span class="nav-number">2.</span> <span class="nav-text">二、RunLoop 对外的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopSourceRef"><span class="nav-number">2.1.</span> <span class="nav-text">CFRunLoopSourceRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopTimerRef"><span class="nav-number">2.2.</span> <span class="nav-text">CFRunLoopTimerRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopObserverRef"><span class="nav-number">2.3.</span> <span class="nav-text">CFRunLoopObserverRef</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、输入事件来源"><span class="nav-number">3.</span> <span class="nav-text">三、输入事件来源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、输入源（input_source）"><span class="nav-number">3.1.</span> <span class="nav-text">1、输入源（input source）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）基于端口的输入源"><span class="nav-number">3.1.1.</span> <span class="nav-text">（1）基于端口的输入源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）自定义输入源"><span class="nav-number">3.1.2.</span> <span class="nav-text">（2）自定义输入源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）Cocoa上的Selector源"><span class="nav-number">3.1.3.</span> <span class="nav-text">（3）Cocoa上的Selector源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、定时源（timer_source）"><span class="nav-number">3.2.</span> <span class="nav-text">2、定时源（timer source）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、RunLoop观察者"><span class="nav-number">4.</span> <span class="nav-text">四、RunLoop观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、RunLoop_的_Mode"><span class="nav-number">5.</span> <span class="nav-text">五、RunLoop 的 Mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、RunLoop的事件队列"><span class="nav-number">6.</span> <span class="nav-text">六、RunLoop的事件队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、什么时候使用run_loop"><span class="nav-number">7.</span> <span class="nav-text">七、什么时候使用run loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、苹果用_RunLoop_实现的功能"><span class="nav-number">8.</span> <span class="nav-text">八、苹果用 RunLoop 实现的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、_App_启动后_RunLoop_的状态"><span class="nav-number">8.1.</span> <span class="nav-text">1、 App 启动后 RunLoop 的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、AutoreleasePool"><span class="nav-number">8.2.</span> <span class="nav-text">2、AutoreleasePool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、事件响应"><span class="nav-number">8.3.</span> <span class="nav-text">3、事件响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、手势识别"><span class="nav-number">8.4.</span> <span class="nav-text">4、手势识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、界面更新"><span class="nav-number">8.5.</span> <span class="nav-text">5、界面更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、定时器"><span class="nav-number">8.6.</span> <span class="nav-text">6、定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、PerformSelecter"><span class="nav-number">8.7.</span> <span class="nav-text">7、PerformSelecter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、关于GCD"><span class="nav-number">8.8.</span> <span class="nav-text">8、关于GCD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、关于网络请求"><span class="nav-number">8.9.</span> <span class="nav-text">9、关于网络请求</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YL</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'aliang9585githubio';
      var disqus_identifier = '2015/09/17/Runloop学习笔记/';
      var disqus_title = 'Runloop学习笔记';
      var disqus_url = 'http://aliang9585.github.io/2015/09/17/Runloop学习笔记/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
