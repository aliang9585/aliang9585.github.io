<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="IOS技术总结" />



  <meta name="keywords" content="RunTime," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="摘录自：
http://www.cocoachina.com/ios/20141018/9960.html
http://blog.zuics.com/runloop-runtime/
http://www.cocoachina.com/ios/20141008/9844.html
http://southpeak.github.io/blog/2014/10/25/objective-c-run">
<meta property="og:type" content="article">
<meta property="og:title" content="RunTime学习总结">
<meta property="og:url" content="http://aliang9585.github.io/2015/08/06/RunTime学习总结/index.html">
<meta property="og:site_name" content="LYL's Blog">
<meta property="og:description" content="摘录自：
http://www.cocoachina.com/ios/20141018/9960.html
http://blog.zuics.com/runloop-runtime/
http://www.cocoachina.com/ios/20141008/9844.html
http://southpeak.github.io/blog/2014/10/25/objective-c-run">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/isaRelationship.png">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/isaRelationship.png">
<meta property="og:image" content="http://7xkfcm.com1.z0.glb.clouddn.com/messaging1.gif">
<meta property="og:updated_time" content="2015-09-08T14:04:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RunTime学习总结">
<meta name="twitter:description" content="摘录自：
http://www.cocoachina.com/ios/20141018/9960.html
http://blog.zuics.com/runloop-runtime/
http://www.cocoachina.com/ios/20141008/9844.html
http://southpeak.github.io/blog/2014/10/25/objective-c-run">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

    <title> RunTime学习总结 // LYL's Blog </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a7a4364608485ad7bc5d2abeacd05591";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<div class="container one-column page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">LYL's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-about"></i> <br />
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              RunTime学习总结
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-06T00:00:00+08:00" content="2015-08-06">
            2015-08-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/08/06/RunTime学习总结/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/08/06/RunTime学习总结/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><blockquote>
<p>摘录自：</p>
<p><a href="http://www.cocoachina.com/ios/20141018/9960.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20141018/9960.html</a></p>
<p><a href="http://blog.zuics.com/runloop-runtime/" target="_blank" rel="external">http://blog.zuics.com/runloop-runtime/</a></p>
<p><a href="http://www.cocoachina.com/ios/20141008/9844.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20141008/9844.html</a></p>
<p><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="external">http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/</a></p>
<p><a href="http://www.cnblogs.com/yswdarren/p/3619303.html" target="_blank" rel="external">http://www.cnblogs.com/yswdarren/p/3619303.html</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_a343f32b0101en4o.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_a343f32b0101en4o.html</a></p>
</blockquote>
<p>RunTime简称运行时。就是系统在运行的时候的一些机制，其中最主要的是消息机制。<br>OC的函数调用称为消息发送，属于动态调用过程。在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。事实上，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。</p>
<h2 id="第一部分：初识RunTime">第一部分：初识RunTime</h2><a id="more"></a>
<h3 id="1、示例代码">1、示例代码</h3><p>Father.h</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">Father :</span> NSObject</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)callMe;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>Father.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"Father.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Father</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)callMe &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"call me father"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>main.m</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#<span class="keyword">import</span> <span class="string">"Father.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@autoreleasepool</span> &#123;</span><br><span class="line">        Father *obj = [[Father alloc] init];</span><br><span class="line">        [obj callMe];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、方法调用如何变成了消息发送">2、方法调用如何变成了消息发送</h3><p>Objective-C之所以能做到运行时才查找要执行的函数主要归功于runTime的SDK。下面我们来看看Objective-C是怎么让程序拥有运行时特性的:</p>
<p>在runTime的SDK下有一个objc_msgSend()的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, …)</span><br></pre></td></tr></table></figure>
<p>在main函数中对于<code>[obj callMe]</code>这样一个简单的调用。在编译时RunTime会把代码转化成</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend<span class="list">(<span class="keyword">obj</span>,@selector<span class="list">(<span class="keyword">callMe</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、理解对象的真实面目">3、理解对象的真实面目</h3><p>command+鼠标左键，依次进入下面几个类</p>
<h4 id="（1）NSObject">（1）NSObject</h4><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在NSObjcet中存在一个Class的isa指针，指向对象对应的Class类</p>
<h4 id="（2）Class">（2）Class</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>我们发现Class是一个指向<code>objc_class</code>的结构体的指针。</p>
<h4 id="（3）objc_class">（3）objc_class</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
<h4 id="（4）解释结构体objc_class的成员">（4）解释结构体objc_class的成员</h4><p>总览：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class isa; <span class="comment">// 指向metaclass</span></span><br><span class="line">Class super_class ; <span class="comment">// 指向其父类</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *name ; <span class="comment">// 类名</span></span><br><span class="line"><span class="built_in">long</span> <span class="keyword">version</span> ; <span class="comment">// 类的版本信息，初始化默认为0，可以通过runtime函数class_setVersion和class_getVersion进行修改、读取</span></span><br><span class="line"><span class="built_in">long</span> info; <span class="comment">// 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line"><span class="built_in">long</span> instance_size ; <span class="comment">// 该类的实例变量大小(包括从父类继承下来的实例变量);</span></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list *ivars; <span class="comment">// 用于存储每个成员变量的地址</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_list **methodLists ; <span class="comment">// 与 info 的一些标志位有关,如CLS_CLASS (0x1L),则存储对象方法，如CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line"><span class="keyword">struct</span> objc_cache *cache; <span class="comment">// 类中方法列表 Cache cache; 查找方法的缓存，用于提升效率；</span></span><br><span class="line"><span class="keyword">struct</span> objc_protocol_list *protocols; <span class="comment">// 存储该类遵守的协议</span></span><br></pre></td></tr></table></figure>
<p>详解：</p>
<ul>
<li>Class isa：指向metaclass，也就是静态的Class。一般一个Obj对象中的isa会指向普通的Class，这个Class中存储普通成员变量和对 象方法（“-”开头的方法），普通Class中的isa指针指向静态Class，静态Class中存储static类型成员变量和类方法（“+”开头的方 法）。<br>需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)</li>
<li><p>Class super_class:指向父类，如果这个类是根类(如NSObject或NSProxy)，则为nil。</p>
<p>  下面一张图片很好的描述了类和对象的继承关系：</p>
<p>  <img src="http://7xkfcm.com1.z0.glb.clouddn.com/isaRelationship.png" alt="类和对象的继承关系"></p>
</li>
</ul>
<blockquote>
<p>注意：所有metaclass中isa指针都指向根metaclass。而根metaclass则指向自身。Root metaclass是通过继承Root class产生的。与root class结构体成员一致，也就是前面提到的结构。不同的是Root metaclass的isa指针指向自身。</p>
</blockquote>
<ul>
<li><p>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</p>
<p>  针对cache，我们用下面例子来说明其执行过程：</p>
  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = <span class="comment">[<span class="comment">[NSArray alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>
<p>  其流程是：</p>
<p>  [NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</p>
<p>  检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</p>
<p>  接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</p>
<p>  在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</p>
</li>
<li><p>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</p>
</li>
</ul>
<h3 id="4、理解调用方法的实质">4、理解调用方法的实质</h3><p>@selector(callMe)：这是一个SEL方法选择器。SEL其主要作用是快速的通过方法名字(callMe)查找到对应方法的函数指针，然后调用其函 数。SEL其本身是一个int类型的一个地址，地址中存放着方法的名字。对于一个类中。每一个方法对应着一个SEL。所以iOS类中不能存在2个名称相同 的方法，即使参数类型不同，因为SEL是根据方法名字生成的，相同的方法名称只能对应一个SEL。</p>
<p>下面我们就来看看具体消息发送之后是怎么来动态查找对应的方法的。</p>
<ol>
<li>首先，编译器将代码[obj callMe]转化为objc_msgSend(obj, @selector (callMe))</li>
<li>在objc_msgSend函数中，首先通过obj的isa指针找到obj对应的class。</li>
<li><p>在Class中先去cache中 通过SEL查找对应函数指针method_imp</p>
<blockquote>
<p>（猜测cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若 cache中未找到。再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</p>
</blockquote>
</li>
<li><p>根据函数指针method_imp调用响应的函数。</p>
</li>
</ol>
<p>另一种解释 </p>
<p>1、当我们调用某个对象的对象方法时，它会首先在自身isa指针指向的类（class）methodLists中查找该方法，如果找不到则会通过class的super_class指针找到其父类，然后从其methodLists中查找该方法，如果仍然找不到，则继续通过 super_class向上一级父类结构体中查找，直至根class；</p>
<p>2、当我们调用某个类方法时，它会首先通过自己的isa指针找到metaclass，并从其methodLists中查找该类方法，如果找不到则会通过metaclass的super_class指针找到父类的metaclass结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查 找，直至根metaclass；</p>
<p>估计大家和我一样，看到这里，好像明白了一些，但许多地方似懂非懂，没关系，第一部分内容就是热热身，不理解没关系，我们继续耐心往下学习。</p>
<h2 id="第二部分：RunTime解惑">第二部分：RunTime解惑</h2><h3 id="1、Runtime_是什么？">1、Runtime 是什么？</h3><p>Objective-C 的 Runtime 是一个运行时库（Runtime Library），它是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。这就是说<strong>它在类信息（Class information） 中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime 创建了所有需要的结构体，让 Objective-C 的面相对象编程变为可能。</strong></p>
<h3 id="2、Runtime_做什么？">2、Runtime 做什么？</h3><p>Runtime库主要做下面几件事：</p>
<ol>
<li><p>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>
</li>
<li><p>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。</p>
</li>
</ol>
<h3 id="3、Modern_Runtime与Legacy_Runtime">3、Modern Runtime与Legacy Runtime</h3><p>Modern Runtime（现代的 Runtime） 和 Legacy Runtime（过时的 Runtime）。Modern Runtime：覆盖所有 64 位的 Mac OS X 应用和所有 iPhone OS 的应用。 </p>
<p>Legacy Runtime: 覆盖其他的所有应用（所有 32 位的 Mac OS X 应用）。</p>
<h3 id="4、Selector">4、Selector</h3><p>在 Objective-C 中 selector 只是一个 C 的数据结构，用于表示一个你想在一个对象上执行的 Objective-C 方法。在 runtime 中的定义像这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector  *SEL;</span><br></pre></td></tr></table></figure>
<p>像这样使用</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">SEL</span> aSel = <span class="variable">@selector</span>(callMe);</span><br></pre></td></tr></table></figure>
<h3 id="5、Message">5、Message</h3><p>消息是方括号 ‘[]’ 中的那部分，由你要向其发送消息的对象（target），你想要在上面执行的方法（method）还有你发送的参数（arguments）组成。 Objective-C 的消息和 C 函数调用是不同的。事实上，你向一个对象发送消息并不意味着它会执行它。Object（对象）会检查消息的发送者，基于这点再决定是执行一个不同的方法还是转发消息到另一个目标对象上。</p>
<h3 id="6、Class、objc_class、objc_object">6、Class、objc_class、objc_object</h3><p>先看看objc.h中Class定义部分：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if !OBJC_TYPES_DEFINED</span></span><br><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an<span class="instruction"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an<span class="instruction"> instance </span>of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针</p>
<p>objc_object： 可以看到，这个结构体只有一个指向其类(Class)的isa指针。当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类(Class)。Runtime库会在类(Class)的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>id 指针：是一个objc_object结构类型的指针。默认情况下 id 指针除了告诉我们它们是 Objective-C 对象外没有其他用了。当你有一个 id 指针，然后你就可以问这个对象是什么类的，看看它是否响应一个方法，等等，然后你就可以在知道这个指针指向的是什么对象后执行更多的操作了。</p>
<h3 id="7、objc_cache">7、objc_cache</h3><p>第一部分解释结构体objc_class的成员时提到了objc_cache<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache *<span class="operator"><span class="keyword">cache</span>;</span> // 类中方法列表 <span class="operator"><span class="keyword">Cache</span> <span class="keyword">cache</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>objc_cache结构如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</p>
<p>occupied：一个整数，指定实际占用的缓存bucket的总数。</p>
<p>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</p>
<h3 id="8、元类(Meta_Class)">8、元类(Meta Class)</h3><p>第一部分解释结构体objc_class的成员时，提到了isa指向metaclass<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> isa; <span class="comment">// 指向metaclass</span></span><br></pre></td></tr></table></figure></p>
<p>我们已经提到过多次：所有的类自身也是一个对象。因此我们可以向这个对象发送消息(即调用类方法)。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = [NSArray <span class="built_in">array</span>];</span><br></pre></td></tr></table></figure>
<p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类(Class)的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念:<strong>meta-class是一个类对象的类</strong>。</p>
<p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p>
<p>meta-class之所以重要，是因为它存储着一个类的所有“类方法”。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>   <img src="http://7xkfcm.com1.z0.glb.clouddn.com/isaRelationship.png" alt="类和对象的继承关系"></p>
<p>示例：测试meta-class<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> class], [<span class="keyword">self</span> superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass = [<span class="keyword">self</span> class];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p"</span>, i, currentClass);</span><br><span class="line">        currentClass = objc_getClass((__bridge <span class="keyword">void</span> *)currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> class]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, objc_getClass((__bridge <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ex_registerClassPair() &#123;</span><br><span class="line">    </span><br><span class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> class], <span class="string">"TestClass"</span>, <span class="number">0</span>);</span><br><span class="line">    class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass2), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    [instance performSelector:<span class="keyword">@selector</span>(testMetaClass2)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        ex_registerClassPair();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：记住 <code>#import &lt;objc/runtime.h&gt;</code></p>
</blockquote>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印输出</span></span><br><span class="line"><span class="comment">//This objcet is 0x1001146a0</span></span><br><span class="line"><span class="comment">//Class is TestClass, super class is NSError</span></span><br><span class="line"><span class="comment">//Following the isa pointer 0 times gives 0x100114470</span></span><br><span class="line"><span class="comment">//Following the isa pointer 1 times gives 0x0</span></span><br><span class="line"><span class="comment">//Following the isa pointer 2 times gives 0x0</span></span><br><span class="line"><span class="comment">//Following the isa pointer 3 times gives 0x0</span></span><br><span class="line"><span class="comment">//NSObject's class is 0x7fff75da40f0</span></span><br><span class="line"><span class="comment">//NSObject's meta class is 0x0</span></span><br></pre></td></tr></table></figure>
<p>这个例子是在运行时创建了一个NSError的子类TestClass，然后为这个子类添加一个方法testMetaClass2，这个方法的实现是TestMetaClass函数。</p>
<p>我们在for循环中，我们通过objc_getClass来获取对象的isa，并将其打印出来，依此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的meta-class的类地址。</p>
<p>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class，它只是返回类而已。</p>
<h2 id="第三部分：RunTime-类与对象操作函数">第三部分：RunTime-类与对象操作函数</h2><p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。</p>
<h3 id="一、类相关操作函数">一、类相关操作函数</h3><h4 id="1、类名">1、类名</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( <span class="keyword">Class</span> cls );</span><br></pre></td></tr></table></figure>
<h4 id="2、父类(super_class)和元类(meta-class)">2、父类(super_class)和元类(meta-class)</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line"><span class="keyword">Class</span> class_getSuperclass ( <span class="keyword">Class</span> cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></span><br><span class="line">BOOL class_isMetaClass ( <span class="keyword">Class</span> cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的元类</span></span><br><span class="line"><span class="keyword">Class</span> objc_getMetaClass ( <span class="keyword">Class</span> cls );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>class_getSuperclass函数，当cls为Nil、nil或者cls为根类时，返回nil(不是Nil)。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</p>
</li>
<li><p>class_isMetaClass函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</p>
</li>
</ul>
<h4 id="3、实例变量大小(instance_size)">3、实例变量大小(instance_size)</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line"><span class="function">size_t <span class="title">class_getInstanceSize</span> <span class="params">( Class cls )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="4、成员变量(ivars)及属性">4、成员变量(ivars)及属性</h4><p>在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>
<p>（1）、成员变量操作函数，主要包含以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<ul>
<li>class_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</li>
</ul>
<blockquote>
<p>Ivar</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; /// An opaque type that represents an<span class="instruction"> instance </span>variable.</span><br><span class="line">&gt; typedef struct objc_ivar *Ivar;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">&gt;     <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&gt;     <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&gt; <span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">&gt;     <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&gt; <span class="preprocessor">#endif</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</p>
</li>
<li><p>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</p>
</li>
<li><p>class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</p>
</li>
</ul>
<p>（2）、属性操作函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line"><span class="keyword">objc_property_t</span> * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这一种方法也是针对ivars来操作，不过只操作那些是属性的值。</p>
<p>（3）、在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * class_getIvarLayout ( Class cls );</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setIvarLayout</span> <span class="params">( Class cls, <span class="keyword">const</span> uint8_t *layout )</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * class_getWeakIvarLayout ( Class cls );</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setWeakIvarLayout</span> <span class="params">( Class cls, <span class="keyword">const</span> uint8_t *layout )</span></span>;</span><br></pre></td></tr></table></figure>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用objc_registerClassPair时，会生成合理的布局。在此不详细介绍这些函数。</p>
<h4 id="5、方法(methodLists)">5、方法(methodLists)</h4><p>方法操作主要有以下函数：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">BOOL class_addMethod ( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getInstanceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getClassMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> * <span class="title">class_copyMethodList</span> <span class="params">( <span class="keyword">Class</span> cls, unsigned int *outCount )</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替代方法的实现</span></span><br><span class="line">IMP class_replaceMethod ( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的具体实现</span></span><br><span class="line">IMP class_getMethodImplementation ( <span class="keyword">Class</span> cls, SEL name );</span><br><span class="line">IMP class_getMethodImplementation_stret ( <span class="keyword">Class</span> cls, SEL name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line">BOOL class_respondsToSelector ( <span class="keyword">Class</span> cls, SEL sel );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数_self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。</p>
<p>  另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
</li>
<li><p>class_getInstanceMethod、class_getClassMethod函数，与class_copyMethodList不同的是，这两个函数都会去搜索父类的实现。</p>
</li>
<li><p>class_copyMethodList函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls), &amp;count)</code>(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</p>
</li>
<li><p>class_replaceMethod函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于class_addMethod函数一样会添加方法；如果类中已存在name指定的方法，则类似于method_setImplementation一样替代原方法的实现。</p>
</li>
<li><p>class_getMethodImplementation函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls, name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</p>
</li>
<li><p>class_respondsToSelector函数，我们通常使用NSObject类的respondsToSelector:或instancesRespondToSelector:方法来达到相同目的。</p>
</li>
</ul>
<h4 id="5、协议(objc_protocol_list)">5、协议(objc_protocol_list)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span> <span class="params">( Class cls, Protocol *protocol )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span> <span class="params">( Class cls, Protocol *protocol )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>class_conformsToProtocol函数可以使用NSObject类的conformsToProtocol:方法来替代。</p>
</li>
<li><p>class_copyProtocolList函数返回的是一个数组，在使用后我们需要使用free()手动释放。</p>
</li>
</ul>
<h4 id="6、版本(version)">6、版本(version)</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">class_getVersion</span> <span class="params">( Class cls )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setVersion</span> <span class="params">( Class cls, <span class="keyword">int</span> version )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="7、其它">7、其它</h4><p>runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setFutureClass</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常我们不直接使用这两个函数。</p>
<h4 id="8、Example">8、Example</h4><p>MyClass.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *string;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyClass.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _instance1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *_instance2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"call method method1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"arg1 : %ld, arg2 : %@"</span>, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>main.m</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"><span class="comment">#import "MyClass.h"</span></span><br><span class="line"><span class="comment">#import &lt;objc/runtime.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="type">NSObject</span> *rootObj = [[<span class="type">NSObject</span> alloc] init];</span><br><span class="line">        <span class="type">Class</span> rootCls = rootObj.class;</span><br><span class="line">        </span><br><span class="line">        <span class="type">MyClass</span> *myClass = [[<span class="type">MyClass</span> alloc] init];</span><br><span class="line">        unsigned <span class="type">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Class</span> cls = myClass.class;</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"类名=========================================================="</span>);</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"class name: %s"</span>, class_getName(cls));//lass name: <span class="type">MyClass</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"class name of Nil: %s"</span>, class_getName(<span class="type">Nil</span>));//class name <span class="keyword">of</span> <span class="type">Nil</span>: <span class="keyword">nil</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"class name of nil: %s"</span>, class_getName(<span class="keyword">nil</span>));//class name <span class="keyword">of</span> <span class="keyword">nil</span>: <span class="keyword">nil</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"class name of rootCls: %s"</span>, class_getName(rootCls));//class name <span class="keyword">of</span> rootCls: <span class="type">NSObject</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"父类=========================================================="</span>);</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"super class name: %s"</span>, class_getName(class_getSuperclass(cls)));//super class name: <span class="type">NSObject</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"super class name of Nil: %s"</span>, class_getName(class_getSuperclass(<span class="type">Nil</span>)));//super class name <span class="keyword">of</span> <span class="type">Nil</span>: <span class="keyword">nil</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"super class name of nil: %s"</span>, class_getName(class_getSuperclass(<span class="keyword">nil</span>)));//super class name <span class="keyword">of</span> <span class="keyword">nil</span>: <span class="keyword">nil</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"super class name of rootCls: %s"</span>, class_getName(class_getSuperclass(rootCls)));//super class name <span class="keyword">of</span> rootCls: <span class="keyword">nil</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"是否是元类=========================================================="</span>);</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"MyClass is %@ a meta-class"</span>, (class_isMetaClass(cls) ? @<span class="string">""</span> : @<span class="string">"not"</span>));//<span class="type">MyClass</span> <span class="keyword">is</span> <span class="keyword">not</span> a meta-class</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"Nil is %@ a meta-class"</span>, (class_isMetaClass(<span class="type">Nil</span>) ? @<span class="string">""</span> : @<span class="string">"not"</span>));//<span class="type">Nil</span> <span class="keyword">is</span> <span class="keyword">not</span> a meta-class</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"nil is %@ a meta-class"</span>, (class_isMetaClass(<span class="keyword">nil</span>) ? @<span class="string">""</span> : @<span class="string">"not"</span>));//<span class="keyword">nil</span> <span class="keyword">is</span> <span class="keyword">not</span> a meta-class</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"获取元类=========================================================="</span>);</span><br><span class="line">        <span class="type">Class</span> meta_class = objc_getMetaClass(class_getName(cls));</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"%s's meta-class is %s"</span>, class_getName(cls), class_getName(meta_class));</span><br><span class="line">        <span class="type">Class</span> meta_rootCls = objc_getMetaClass(class_getName(rootCls));</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"%s's meta-class is %s"</span>, class_getName(rootCls), class_getName(meta_rootCls));</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"变量实例大小=========================================================="</span>);</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"instance size: %zu"</span>, class_getInstanceSize(cls));//instance size: <span class="number">48</span></span><br><span class="line"></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"成员变量=========================================================="</span>);</span><br><span class="line">        <span class="type">Ivar</span> *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            <span class="type">Ivar</span> ivar = ivars[i];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"instance variable's name: %s at index: %d"</span>, ivar_getName(ivar), i);</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">        //instance variable's name: _instance1 at index: <span class="number">0</span></span><br><span class="line">        //instance variable's name: _instance2 at index: <span class="number">1</span></span><br><span class="line">        //instance variable's name: _array at index: <span class="number">2</span></span><br><span class="line">        //instance variable's name: _string at index: <span class="number">3</span></span><br><span class="line">        //instance variable's name: _integer at index: <span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Ivar</span> ivar = class_getInstanceVariable(cls, <span class="string">"_string"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ivar != <span class="type">NULL</span>) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"instace variable by name _string is %s"</span>, ivar_getName(ivar));</span><br><span class="line">        &#125;</span><br><span class="line">        //instace variable by name _string <span class="keyword">is</span> _string</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"属性操作=========================================================="</span>);</span><br><span class="line">        objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"property's name: %s"</span>, property_getName(property));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        free(properties);</span><br><span class="line">        </span><br><span class="line">        objc_property_t <span class="type">array</span> = class_getProperty(cls, <span class="string">"array"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">array</span> != <span class="type">NULL</span>) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"property %s"</span>, property_getName(<span class="type">array</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        //property's name: <span class="type">array</span></span><br><span class="line">        //property's name: <span class="type">string</span></span><br><span class="line">        //property's name: integer</span><br><span class="line">        //property <span class="type">array</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"方法操作=========================================================="</span>);</span><br><span class="line">        <span class="type">Method</span> *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="keyword">method</span> = methods[i];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"method's signature: %s"</span>, method_getName(<span class="keyword">method</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        free(methods);</span><br><span class="line">        //<span class="keyword">method</span>'s signature: method1</span><br><span class="line">        //<span class="keyword">method</span>'s signature: method2</span><br><span class="line">        //<span class="keyword">method</span>'s signature: method3WithArg1:arg2:</span><br><span class="line">        //<span class="keyword">method</span>'s signature: integer</span><br><span class="line">        //<span class="keyword">method</span>'s signature: setInteger:</span><br><span class="line">        //<span class="keyword">method</span>'s signature: <span class="type">array</span></span><br><span class="line">        //<span class="keyword">method</span>'s signature: <span class="type">string</span></span><br><span class="line">        //<span class="keyword">method</span>'s signature: setString:</span><br><span class="line">        //<span class="keyword">method</span>'s signature: setArray:</span><br><span class="line">        //<span class="keyword">method</span>'s signature: .cxx_destruct ？？？这是毛玩意</span><br><span class="line">        </span><br><span class="line">        <span class="type">Method</span> method1 = class_getInstanceMethod(cls, @selector(method1));</span><br><span class="line">        <span class="keyword">if</span> (method1 != <span class="type">NULL</span>) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"method %s"</span>, method_getName(method1));</span><br><span class="line">        &#125;</span><br><span class="line">        //<span class="keyword">method</span> method1</span><br><span class="line">        </span><br><span class="line">        <span class="type">Method</span> classMethod = class_getClassMethod(cls, @selector(classMethod1));</span><br><span class="line">        <span class="keyword">if</span> (classMethod != <span class="type">NULL</span>) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"class method : %s"</span>, method_getName(classMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        //class <span class="keyword">method</span> : classMethod1</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"MyClass is%@ responsd to selector: method3WithArg1:arg2:"</span>, class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @<span class="string">" realy"</span> : @<span class="string">" not"</span>);</span><br><span class="line">        //<span class="type">MyClass</span> <span class="keyword">is</span> realy responsd to selector: method3WithArg1:arg2:</span><br><span class="line">        </span><br><span class="line">        <span class="type">IMP</span> imp = class_getMethodImplementation(cls, @selector(method1));</span><br><span class="line">        imp();</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"协议=========================================================="</span>);</span><br><span class="line">        <span class="type">Protocol</span> * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">        <span class="type">Protocol</span> * protocol;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            protocol = protocols[i];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"protocol name: %s"</span>, protocol_getName(protocol));</span><br><span class="line">        &#125;</span><br><span class="line">        //..............无输出</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"MyClass is%@ responsed to protocol %s"</span>, class_conformsToProtocol(cls, protocol) ? @<span class="string">""</span> : @<span class="string">" not"</span>, protocol_getName(protocol));</span><br><span class="line">        //<span class="type">MyClass</span> <span class="keyword">is</span> <span class="keyword">not</span> responsed to protocol <span class="keyword">nil</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、动态创建类和对象">二、动态创建类和对象</h3><h4 id="1、动态创建类">1、动态创建类</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新类和元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span> <span class="params">( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span> <span class="params">( Class cls )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span> <span class="params">( Class cls )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</p>
<p>为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>，<code>class_addIvar</code>等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p><strong><em>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</em></strong></p>
</li>
<li><p><code>objc_disposeClassPair</code>函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</p>
</li>
</ul>
<h4 id="补充：Method_与_IMP">补充：Method 与 IMP</h4><p>Method</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></span><br><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line">struct objc_method <span class="comment">&#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一个方法 Method，其包含一个方法选择器 SEL – 表示该方法的名称，一个types – 表示该方法参数的类型，一个 IMP  - 指向该方法的具体实现的函数指针。</p>
<p>IMP</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>id是一个指向 objc_object 结构体的指针，该结构体只有一个成员isa，所以任何继承自 NSObject 的类对象都可以用id 来指代，因为 NSObject 的第一个成员实例就是isa。</p>
<p>IMP 是一个函数指针，这个被指向的函数包含一个接收消息的对象id(self  指针), 调用方法的选标 SEL (方法名)，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码 。</p>
<p>NSObject 类中的methodForSelector：方法就是这样一个获取指向方法实现IMP 的指针，methodForSelector：返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP imp = [<span class="keyword">self</span> methodForSelector:<span class="keyword">selector</span>];</span><br></pre></td></tr></table></figure>
<p>NSObject里面的这两个方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">IMP</span>)<span class="rule"><span class="attribute">methodForSelector</span>:<span class="value">(SEL)aSelector</span></span>;</span><br><span class="line">+ (<span class="tag">IMP</span>)<span class="rule"><span class="attribute">instanceMethodForSelector</span>:<span class="value">(SEL)aSelector</span></span>;</span><br></pre></td></tr></table></figure>
<p>用法举例</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//    SEL 与 IMP 用法</span><br><span class="line">SEL sel = @selector(<span class="keyword">say</span>);//也可以这样写：SEL sel=NSSelectorFromString(@<span class="string">"say"</span>);</span><br><span class="line"></span><br><span class="line">IMP imp1 = <span class="comment">[obj methodForSelector:sel]</span>;</span><br><span class="line">IMP imp2 = <span class="comment">[obj methodForSelector:sel]</span>;</span><br><span class="line">   </span><br><span class="line">imp1(obj,sel);</span><br><span class="line">imp2(obj,sel);</span><br></pre></td></tr></table></figure>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void ex_registerClassPair<span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    SEL 与 IMP 用法</span></span><br><span class="line"><span class="comment">//    SEL sel = @selector(say);//也可以这样写：SEL sel=NSSelectorFromString(@"say");不报警告</span></span><br><span class="line"><span class="comment">//    IMP imp1 = [obj methodForSelector:sel];</span></span><br><span class="line"><span class="comment">//    IMP imp2 = [obj methodForSelector:sel];</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    imp1(obj,sel);</span></span><br><span class="line"><span class="comment">//    imp2(obj,sel);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态创建类</span></span><br><span class="line">    Class cls = objc_allocateClassPair<span class="params">(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态往类中添加方法</span></span><br><span class="line">    class_addMethod<span class="params">(cls, @selector<span class="params">(submethod1)</span>, <span class="params">(IMP)</span>imp_submethod1, <span class="string">"v@:"</span>)</span>;</span><br><span class="line">    <span class="comment">//下面这么写可不再出现警告</span></span><br><span class="line">    <span class="comment">//SEL submethod_sel1 = NSSelectorFromString(@"submethod1");</span></span><br><span class="line">    <span class="comment">//class_addMethod(cls, submethod_sel1, (IMP)imp_submethod1, "v@:");</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//替换父类的method1实现</span></span><br><span class="line">    class_replaceMethod<span class="params">(cls, @selector<span class="params">(method1)</span>, <span class="params">(IMP)</span>imp_submethod1, <span class="string">"v@:"</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态添加实例变量</span></span><br><span class="line">    class_addIvar<span class="params">(cls, <span class="string">"_ivar1"</span>, sizeof<span class="params">(NSString *)</span>, log<span class="params">(sizeof<span class="params">(NSString *)</span>)</span>, <span class="string">"i"</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态添加属性</span></span><br><span class="line">    objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</span><br><span class="line">    objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</span><br><span class="line">    objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</span><br><span class="line">    objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line">    class_addProperty<span class="params">(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册Class</span></span><br><span class="line">    objc_registerClassPair<span class="params">(cls)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态创建实例</span></span><br><span class="line">    id instance = [[cls alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态调用实例方法</span></span><br><span class="line">    [instance performSelector:@selector<span class="params">(submethod1)</span>];</span><br><span class="line">    [instance performSelector:@selector<span class="params">(method1)</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main<span class="params">(int argc, const char * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ex_registerClassPair<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、动态创建对象">2、动态创建对象</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure>
<ul>
<li>class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</li>
<li>objc_constructInstance函数：在指定的位置(bytes)创建类实例。</li>
<li>objc_destructInstance函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</li>
</ul>
<p>调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p>
<p>注意：需关闭ARC</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span><span class="variable">.class</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line">        <span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 class]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 class]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NSString</span></span><br><span class="line">        <span class="comment">// __NSCFConstantString</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是NSString实例，而不是类簇中的默认占位符类<code>__NSCFConstantString</code>。</p>
<h3 id="三、实例操作函数">三、实例操作函数</h3><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<h4 id="1-针对整个对象进行操作的函数，这类函数包含">1.针对整个对象进行操作的函数，这类函数包含</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSObject *a = [[NSObject alloc] init];</span><br><span class="line">id newB = <span class="keyword">object</span><span class="number">_</span>copy(a, <span class="keyword">class</span><span class="number">_</span>getInstanceSize(MyClass.<span class="keyword">class</span>));</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>setClass(newB, MyClass.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>dispose(a);</span><br></pre></td></tr></table></figure>
<h4 id="2-针对对象实例变量进行操作的函数，这类函数包含：">2.针对对象实例变量进行操作的函数，这类函数包含：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</span><br></pre></td></tr></table></figure>
<p>如果实例变量的Ivar已经知道，那么调用object_getIvar会比object_getInstanceVariable函数快，相同情况下，object_setIvar也比object_setInstanceVariable快。</p>
<h4 id="3-针对对象的类进行操作的函数，这类函数包含：">3.针对对象的类进行操作的函数，这类函数包含：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line">Class object_getClass ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</span><br></pre></td></tr></table></figure>
<h3 id="四、获取类定义">四、获取类定义</h3><p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用objc_addClass函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span> <span class="params">( Class *buffer, <span class="keyword">int</span> bufferCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的类定义</span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>objc_getClassList函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</li>
</ul>
<p>下面代码演示了该函数的用法(需关闭ARC)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> numClasses;</span><br><span class="line">        Class *  classes = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</span><br><span class="line">            numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                Class cls = classes[i];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            free(classes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>获取类定义的方法有三个：objc_lookUpClass, objc_getClass和objc_getRequiredClass。如果类在运行时未注册，则objc_lookUpClass会返回nil，而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程。</p>
</li>
<li><p>objc_getMetaClass函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>
</li>
</ul>
<h2 id="第四部分：RunTime-成员变量与属性">第四部分：RunTime-成员变量与属性</h2><h3 id="一、类型编码(Type_Encoding)">一、类型编码(Type Encoding)</h3><p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以用于@encode()。</p>
<p>在Objective-C Runtime Programming Guide中的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encoding</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>
<p>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</p>
<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> a[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">NSLog(@<span class="string">"array encoding type: %s"</span>, <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(a)));</span><br><span class="line"><span class="comment">//输出是：array encoding type: [3f]</span></span><br></pre></td></tr></table></figure>
<p>另外，还有些编码类型，@encode虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a>。</p>
<h3 id="二、Category的关联对象、成员变量、属性">二、Category的关联对象、成员变量、属性</h3><p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>
<h4 id="1、基础数据类型">1、基础数据类型</h4><h5 id="Ivar">Ivar</h5><p>Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 基地址偏移字节</span></span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="objc_property_t">objc_property_t</h5><p>objc_property_t是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *<span class="keyword">objc_property_t</span>;</span><br></pre></td></tr></table></figure>
<h5 id="objc_property_attribute_t">objc_property_attribute_t</h5><p>objc_property_attribute_t定义了属性的特性(attribute)，它是一个结构体，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 特性名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 特性值</span></span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2、关联对象(Associated_Object)">2、关联对象(Associated Object)</h4><p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(Ivar)放在类声明的头文件中，或者放在类实现的@implementation后面。但这有一个缺点，我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是Ivar，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(Associated Object)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void指针(const void *)。我们还需要指定一个内存管理策略，以告诉Runtime如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSO<span class="built_in">CIATION_ASSIGN</span></span><br><span class="line">OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span></span><br><span class="line">OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span></span><br><span class="line">OBJC_ASSO<span class="built_in">CIATION_RETAIN</span></span><br><span class="line">OBJC_ASSO<span class="built_in">CIATION_COPY</span></span><br></pre></td></tr></table></figure>
<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是assign，则宿主释放时，关联对象不会被释放；而如果指定的是retain或者是copy，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动retain/copy。当我们需要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</span><br><span class="line"></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSO<span class="built_in">CIATION_RETAIN</span>);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，self对象将获取一个新的关联的对象anObject，且内存管理策略是自动retain关联对象，当self对象释放时，会自动release关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    id objc_getAssociatedObject (</span></span><br><span class="line"><span class="comment">//                                 id object,</span></span><br><span class="line"><span class="comment">//                                 const void *key</span></span><br><span class="line"><span class="comment">//                                 );</span></span><br><span class="line"><span class="keyword">id</span> anObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</span><br></pre></td></tr></table></figure>
<p>我们可以使用objc_removeAssociatedObjects函数来移除一个关联对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。</p>
<p>我们下面来用实例演示一下关联对象的使用方法。</p>
<p>问题：<br>我们相对项目中所有UIView都添加一个Tap手势，并传入一个block参数，使得UIView在点击时可以执行block中德内容。</p>
<p>思路：<br>毫无疑问我们会考虑使用基于UIView的Category，增加一个方法：</p>
<p>UIView+TapAction.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">TapAction</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Attaches the given block for a single tap action to the receiver.</span><br><span class="line"> @param block The block to execute.</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>然后开始信心十足的写实现代码：<br>UIView+TapAction.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIView+TapAction.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">TapAction</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">    [<span class="keyword">self</span> addGestureRecognizer:gesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(<span class="built_in">UITapGestureRecognizer</span> *)gesture</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gesture<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateRecognized</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何取得setTapActionWithBlock中德block参数呢</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>写到这里你遇见问题了，你可能马上会想到用全局变量来储存block，但前文说过：“……使用(甚至是滥用)全局变量来解决这个问题,但这些都不是Ivar，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。”</p>
<p>所以说放弃吧，骚年，用用我们的关联对象，轻松搞定：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIView+TapAction.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> kDTActionHandlerTapBlockKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">TapAction</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">    [<span class="keyword">self</span> addGestureRecognizer:gesture];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSO<span class="built_in">CIATION_COPY</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(<span class="built_in">UITapGestureRecognizer</span> *)gesture</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gesture<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateRecognized</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span>(^action)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (action)</span><br><span class="line">        &#123;</span><br><span class="line">            action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>ViewController.m 中测试</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"UIView+TapAction.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> setTapActionWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"The view tapped !"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<p>原文中setTapActionWithBlock的实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *gesture = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gesture)</span><br><span class="line">    &#123;</span><br><span class="line">        gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">        [<span class="keyword">self</span> addGestureRecognizer:gesture];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSO<span class="built_in">CIATION_RETAIN</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSO<span class="built_in">CIATION_COPY</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时我不清楚为什么要设置gesture关联对象，后来想到了：既然有[self addGestureRecognizer:gesture]，那可能还需要[self removeGestureRecognizer:gesture],此时就需要取得gesture这个关联对象。</p>
<p>此处示例代码，南峰子大神也是参考了<a href="http://www.cocoanetics.com/2012/06/associated-objects/" target="_blank" rel="external">这里</a>代码来自 <a href="https://github.com/Cocoanetics/DTFoundation" target="_blank" rel="external">DTFoundation project on GitHub</a>, look for UIView+DTActionHandlers</p>
<h4 id="3、成员变量、属性的操作方法">3、成员变量、属性的操作方法</h4><h5 id="（1）成员变量">（1）成员变量</h5><p>成员变量操作包含以下函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line"><span class="function">ptrdiff_t <span class="title">ivar_getOffset</span> <span class="params">( Ivar v )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>ivar_getOffset函数，对于类型id或其它对象类型的实例变量，可以调用object_getIvar和object_setIvar来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h5 id="（2）关联对象">（2）关联对象</h5><p>关联对象操作函数包括以下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span> (<span class="params"> id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy </span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span> (<span class="params"> id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key </span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span> (<span class="params"> id <span class="keyword">object</span> </span>)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="（3）属性">（3）属性</h5><p>属性操作相关函数包括以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( <span class="keyword">objc_property_t</span> property );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( <span class="keyword">objc_property_t</span> property );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="keyword">char</span> * property_copyAttributeValue ( <span class="keyword">objc_property_t</span> property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line"><span class="keyword">objc_property_attribute_t</span> * property_copyAttributeList ( <span class="keyword">objc_property_t</span> property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>property_copyAttributeValue函数，返回的char *在使用完后需要调用free()释放。</p>
</li>
<li><p>property_copyAttributeList函数，返回值在使用完后需要调用free()释放。</p>
</li>
</ul>
<h4 id="4、示例">4、示例</h4><p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MyObject</span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString    *   name;                  </span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString    *   status;                 </span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>接口A、B返回的字典数据如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@&#123;</span><span class="at_rule">@<span class="string">"name1"</span>: <span class="string">"张三"</span>, @<span class="string">"status1"</span>: @<span class="string">"start"</span>&#125;</span><br><span class="line"></span><br><span class="line">@&#123;</span><span class="at_rule">@<span class="string">"name2"</span>: <span class="string">"张三"</span>, @<span class="string">"status2"</span>: @<span class="string">"end"</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>先看看通常的实现方法，是写两个方法分别做转换：</p>
<p>main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSDictionary</span> *dic1 = @&#123;<span class="string">@"name1"</span>: <span class="string">@"张三"</span>, <span class="string">@"status1"</span>: <span class="string">@"start"</span>&#125;;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dic2 = @&#123;<span class="string">@"name2"</span>: <span class="string">@"李四"</span>, <span class="string">@"status2"</span>: <span class="string">@"end"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通常的实现方法</span></span><br><span class="line">        MyObject *myObj1 = [[MyObject alloc] init];</span><br><span class="line">        MyObject *myObj2 = [[MyObject alloc] init];</span><br><span class="line">        <span class="comment">//方法1：转换dic1</span></span><br><span class="line">        [dic1 enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name1"</span>]) &#123;</span><br><span class="line">                myObj1<span class="variable">.name</span> = obj;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"status1"</span>]) &#123;</span><br><span class="line">                myObj1<span class="variable">.status</span> = obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//方法2：转换dic2</span></span><br><span class="line">        [dic2 enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name2"</span>]) &#123;</span><br><span class="line">                myObj2<span class="variable">.name</span> = obj;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"status2"</span>]) &#123;</span><br><span class="line">                myObj2<span class="variable">.status</span> = obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myObj1`s name is %@, status is %@"</span>,myObj1<span class="variable">.name</span>,myObj1<span class="variable">.status</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"myObj2`s name is %@, status is %@"</span>,myObj2<span class="variable">.name</span>,myObj2<span class="variable">.status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法十分原始，当属性较多时，这么写显然十分麻烦。</p>
<p>也许你会想到，可以利用KVC批量设置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[myObj1 setValuesForKeysWithDictionary:dic1]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>但是KVC批量转的时候，有个致命的缺点，就是当字典中的键，在对象属性中找不到对应的属性的时候会报错。这个时候，我们不妨反过来想一下：我们先获取到对象所有的属性名，然后加入到一个数组里面，然后再遍历，赋值。在程序运行的时候，抓取对象的属性，这时候，要利用到Runtime机制了：</p>
<p>灵活运用Runtime的实现方法：</p>
<p>main.m<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"><span class="comment">#import "MyObject.h"</span></span><br><span class="line"></span><br><span class="line">int <span class="keyword">main</span>(int argc, const char * argv[]<span class="keyword">) &#123;</span></span><br><span class="line">    @<span class="keyword">autoreleasepool &#123;</span></span><br><span class="line">        </span><br><span class="line">        <span class="constant">N</span>SDictionary *dic1 = @<span class="keyword">&#123;</span>@<span class="string">"name1"</span>: @<span class="string">"张三"</span>, @<span class="string">"status1"</span>: @<span class="string">"start"</span><span class="keyword">&#125;</span>;</span><br><span class="line">        <span class="constant">N</span>SDictionary *dic2 = @<span class="keyword">&#123;</span>@<span class="string">"name2"</span>: @<span class="string">"李四"</span>, @<span class="string">"status2"</span>: @<span class="string">"end"</span><span class="keyword">&#125;</span>;</span><br><span class="line">        </span><br><span class="line">        /*//通常的实现方法</span><br><span class="line">        <span class="constant">My</span>Object *myObj1 = [[<span class="constant">My</span>Object alloc] init];</span><br><span class="line">        <span class="constant">My</span>Object *myObj2 = [[<span class="constant">My</span>Object alloc] init];</span><br><span class="line">        //方法<span class="number">1</span>：转换dic1</span><br><span class="line">        [dic1 enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">id</span> key, <span class="built_in">id</span> obj, <span class="constant">B</span>OOL *<span class="keyword">stop) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> ([key isEqualToString:@<span class="string">"name1"</span>]<span class="keyword">) &#123;</span></span><br><span class="line">                myObj1.<span class="literal">name</span> = obj;</span><br><span class="line">            <span class="keyword">&#125;</span><span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:@<span class="string">"status1"</span>]<span class="keyword">) &#123;</span></span><br><span class="line">                myObj1.<span class="literal">status</span> = obj;</span><br><span class="line">            <span class="keyword">&#125;</span></span><br><span class="line">        <span class="keyword">&#125;</span>];</span><br><span class="line">        //方法<span class="number">2</span>：转换dic2</span><br><span class="line">        [dic2 enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">id</span> key, <span class="built_in">id</span> obj, <span class="constant">B</span>OOL *<span class="keyword">stop) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> ([key isEqualToString:@<span class="string">"name2"</span>]<span class="keyword">) &#123;</span></span><br><span class="line">                myObj2.<span class="literal">name</span> = obj;</span><br><span class="line">            <span class="keyword">&#125;</span><span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:@<span class="string">"status2"</span>]<span class="keyword">) &#123;</span></span><br><span class="line">                myObj2.<span class="literal">status</span> = obj;</span><br><span class="line">            <span class="keyword">&#125;</span></span><br><span class="line">        <span class="keyword">&#125;</span>];</span><br><span class="line">        <span class="constant">N</span>SLog(@<span class="string">"myObj1`s name is %@, status is %@"</span>,myObj1.<span class="literal">name</span>,myObj1.<span class="literal">status</span>);</span><br><span class="line">        <span class="constant">N</span>SLog(@<span class="string">"myObj2`s name is %@, status is %@"</span>,myObj2.<span class="literal">name</span>,myObj2.<span class="literal">status</span>);*/</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //运用runtime实现</span><br><span class="line">        <span class="constant">My</span>Object *myObj1 = [[<span class="constant">My</span>Object alloc] initWithDic:dic1];</span><br><span class="line">        <span class="constant">My</span>Object *myObj2 = [[<span class="constant">My</span>Object alloc] initWithDic:dic2];</span><br><span class="line">        </span><br><span class="line">        <span class="constant">N</span>SLog(@<span class="string">"myObj1`s name is %@, status is%@"</span>,myObj1.<span class="literal">name</span>,myObj1.<span class="literal">status</span>);</span><br><span class="line">        <span class="constant">N</span>SLog(@<span class="string">"myObj2`s name is %@, status is%@"</span>,myObj2.<span class="literal">name</span>,myObj2.<span class="literal">status</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">&#125;</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>MyObject.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDic:(<span class="built_in">NSDictionary</span> *)dic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyObject.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyObject.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *map = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    map = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    map[<span class="string">@"name1"</span>]     = <span class="string">@"name"</span>;</span><br><span class="line">    map[<span class="string">@"status1"</span>]   = <span class="string">@"status"</span>;</span><br><span class="line">    map[<span class="string">@"name2"</span>]     = <span class="string">@"name"</span>;</span><br><span class="line">    map[<span class="string">@"status2"</span>]   = <span class="string">@"status"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDic:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setDataWithDic:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDataWithDic:(<span class="built_in">NSDictionary</span> *)dic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *selfPropertyArray =  [<span class="keyword">self</span> getSelfPropertyList];</span><br><span class="line">    [dic enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="comment">//先判断map中是否包含dic中的键</span></span><br><span class="line">        <span class="keyword">if</span> ([map<span class="variable">.allKeys</span> containsObject:key]) &#123;</span><br><span class="line">            <span class="comment">//判断map中对应的值</span></span><br><span class="line">            <span class="built_in">NSString</span> *matchedSelfPropertyName = [map objectForKey:key];</span><br><span class="line">            <span class="comment">//判断map中对应的值是否是self的一个属性名称</span></span><br><span class="line">            <span class="keyword">if</span> ([selfPropertyArray containsObject:matchedSelfPropertyName])&#123;</span><br><span class="line">                <span class="comment">//如果是，用KVC赋值</span></span><br><span class="line">                [<span class="keyword">self</span> setValue:obj forKey:matchedSelfPropertyName];</span><br><span class="line">                <span class="comment">//objc_property_t property = class_getProperty([self class], [matchedSelfPropertyName UTF8String]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//runtime获取自身属性列表</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)getSelfPropertyList &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *list = class_copyPropertyList([<span class="keyword">self</span> class], &amp;outCount);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:outCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; ++i) &#123;</span><br><span class="line">        objc_property_t temp = list[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *pName = property_getName(temp);</span><br><span class="line">        [mArray addObject:[<span class="built_in">NSString</span> stringWithUTF8String:pName]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(list);</span><br><span class="line">    <span class="keyword">return</span> [mArray <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="第五部分：RunTime-消息发送及消息转发">第五部分：RunTime-消息发送及消息转发</h2><h3 id="一、基础数据类型">一、基础数据类型</h3><h4 id="1、SEL">1、SEL</h4><p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// <span class="type">An</span> opaque <span class="keyword">type</span> that represents a <span class="keyword">method</span> selector.</span><br><span class="line">typedef struct objc_selector *<span class="type">SEL</span>;</span><br></pre></td></tr></table></figure>
<p>objc_selector结构体的详细定义没有在<objc runtime.h="">头文件中找到。方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(int类型的地址)，这个标识就是SEL。如下代码所示：</objc></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEL sel1 = <span class="variable">@selector</span>(method1);</span><br><span class="line">NSLog(<span class="variable">@"</span>sel : <span class="variable">%p</span><span class="string">", sel1);</span></span><br></pre></td></tr></table></figure>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。</p>
<p>例如：新建两个类，MyObjectA，MyObjectB，内容都如下</p>
<p>.h</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">void</span>)</span>addressOfSelector_myTest1<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>.m</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>addressOfSelector_myTest1 &#123;</span><br><span class="line">    SEL sel1 = @selector<span class="params">(my<span class="variable">Test1</span>)</span>;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"sel : %p"</span>, sel1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>myTest1 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后在main.m中调用；</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectA.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectB.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObjectA *objA = [[MyObjectA alloc] init];</span><br><span class="line">        MyObjectA *objB = [[MyObjectA alloc] init];</span><br><span class="line">        [objA addressOfSelector_myTest1];</span><br><span class="line">        [objB addressOfSelector_myTest1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现打印结果相同：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sel </span>: <span class="number">0x100000f1e</span></span><br><span class="line"><span class="keyword">sel </span>: <span class="number">0x100000f1e</span></span><br></pre></td></tr></table></figure>
<p>这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">setWidth</span>:<span class="value">(int)width</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">setWidth</span>:<span class="value">(double)width</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(<span class="tag">void</span>)<span class="rule"><span class="attribute">setWidthIntValue</span>:<span class="value">(int)width</span></span>;</span><br><span class="line"><span class="tag">-</span>(<span class="tag">void</span>)<span class="rule"><span class="attribute">setWidthDoubleValue</span>:<span class="value">(double)width</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</p>
<p>工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>
<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>
<ol>
<li>sel_registerName函数</li>
<li>Objective-C编译器提供的@selector()</li>
<li>NSSelectorFromString()方法</li>
</ol>
<h4 id="2、IMP">2、IMP</h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span></span><br></pre></td></tr></table></figure>
<p>这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。</p>
<p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<blockquote>
<p>IMP可以从NSObject类提供了<code>methodForSelector:</code>方法得到。通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<p>例如，可把前面的列子改为：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; #import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"><span class="blockquote">&gt; #import &lt;objc/runtime.h&gt;</span></span><br><span class="line"><span class="blockquote">&gt; #import "MyObjectA.h"</span></span><br><span class="line"><span class="blockquote">&gt; #import "MyObjectB.h"</span></span><br><span class="line"><span class="blockquote">&gt; </span><br><span class="line">&gt; int main(int argc, const char * argv[]) &#123;</span></span><br><span class="line"><span class="blockquote">&gt;     @autoreleasepool &#123;</span></span><br><span class="line"><span class="blockquote">&gt;         /*</span></span><br><span class="line"><span class="blockquote">&gt;         MyObjectA *objA = [[MyObjectA alloc] init];</span></span><br><span class="line"><span class="blockquote">&gt;         MyObjectA *objB = [[MyObjectA alloc] init];</span></span><br><span class="line"><span class="blockquote">&gt;         [objA addressOfSelector_myTest1];</span></span><br><span class="line"><span class="blockquote">&gt;         [objB addressOfSelector_myTest1];</span></span><br><span class="line"><span class="blockquote">&gt;         */</span></span><br><span class="line"><span class="blockquote">&gt;         </span><br><span class="line">&gt;         MyObjectA *objA = [[MyObjectA alloc] init];</span></span><br><span class="line"><span class="blockquote">&gt;         MyObjectA *objB = [[MyObjectA alloc] init];</span></span><br><span class="line"><span class="blockquote">&gt;         SEL sel = NSSelectorFromString(@"addressOfSelector_myTest1");</span></span><br><span class="line"><span class="blockquote">&gt;         IMP impA = [objA methodForSelector:sel];</span></span><br><span class="line"><span class="blockquote">&gt;         IMP impB = [objB methodForSelector:sel];</span></span><br><span class="line"><span class="blockquote">&gt;         impA();</span></span><br><span class="line"><span class="blockquote">&gt;         impB();</span></span><br><span class="line"><span class="blockquote">&gt;     &#125;</span></span><br><span class="line"><span class="blockquote">&gt;     return 0;</span></span><br><span class="line"><span class="blockquote">&gt; &#125;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3、Method">3、Method</h4><p>介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义中的方法，则定义如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line">struct objc_method <span class="comment">&#123;</span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名</span><br><span class="line">    char *method_types                  OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。具体操作流程我们将在下面讨论。</p>
<p>objc_method_description：</p>
<p>objc_method_description定义了一个Objective-C方法，其定义如下：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> </span>&#123; SEL name; char *types; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、方法相关操作函数">二、方法相关操作函数</h3><p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h4 id="1、方法">1、方法</h4><p>方法操作相关函数包括下以：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现</span></span><br><span class="line">id method_invoke ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></span><br><span class="line">void method_invoke_stret ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">SEL method_getName ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line">IMP method_getImplementation ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="keyword">const</span> char * method_getTypeEncoding ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line">char * method_copyReturnType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line">char * method_copyArgumentType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">index</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line">void method_getReturnType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">char</span> *<span class="title">dst</span>, <span class="title">size_t</span> <span class="title">dst_len</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line">unsigned int method_getNumberOfArguments ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line">void method_getArgumentType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">index</span>, <span class="title">char</span> *<span class="title">dst</span>, <span class="title">size_t</span> <span class="title">dst_len</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line">struct objc_method_description * method_getDescription ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line">IMP method_setImplementation ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">IMP</span> <span class="title">imp</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations ( <span class="function"><span class="keyword">Method</span> <span class="title">m1</span>, <span class="title">Method</span> <span class="title">m2</span> );</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>method_invoke函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比method_getImplementation和method_getName更快。</p>
</li>
<li><p>method_getName函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用sel_getName(method_getName(method))。</p>
</li>
<li><p>method_getReturnType函数，类型字符串会被拷贝到dst中。</p>
</li>
<li><p>method_setImplementation函数，注意该函数返回值是方法之前的实现。</p>
</li>
</ul>
<h4 id="2、方法选择器">2、方法选择器</h4><p>选择器相关的操作函数包括：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 返回给定选择器指定的方法的名称</span><br><span class="line"><span class="label">const</span> char * <span class="keyword">sel_getName </span>( <span class="keyword">SEL </span><span class="keyword">sel </span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span><br><span class="line"><span class="keyword">SEL </span><span class="keyword">sel_registerName </span>( const char *<span class="keyword">str </span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法</span><br><span class="line"><span class="keyword">SEL </span><span class="keyword">sel_getUid </span>( const char *<span class="keyword">str </span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 比较两个选择器</span><br><span class="line"><span class="keyword">BOOL </span><span class="keyword">sel_isEqual </span>( <span class="keyword">SEL </span>lhs, <span class="keyword">SEL </span>rhs )<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h3 id="三、方法调用流程">三、方法调用流程</h3><h4 id="1、流程">1、流程</h4><p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector)</span></span></span><br></pre></td></tr></table></figure>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector, arg1, arg2, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们前面章节讨论过的结构体objc_class，这个结构体有两个字段是我们在分发消息的关注的：</p>
<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即methodLists。</li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：</p>
<p><img src="http://7xkfcm.com1.z0.glb.clouddn.com/messaging1.gif" alt="消息的基本框架"></p>
<p>当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程，这个我们在后面讨论。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。这点我们在前面讨论过，不再重复。</p>
<h4 id="2、隐藏参数">2、隐藏参数</h4><p>objc_msgSend有两个隐藏参数：</p>
<p>消息接收对象<br>方法的selector<br>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd来引用选择器。如下代码所示：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    <span class="type">SEL</span> <span class="keyword">method</span> = getTheMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( target == self || <span class="keyword">method</span> == _cmd )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> [target performSelector:<span class="keyword">method</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这两个参数我们用得比较多的是self，_cmd在实际中用得比较少。</p>
<h4 id="3、获取方法地址">3、获取方法地址</h4><p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<p>示例:完整示例请参考上文讲解IMP的部分，在此重新列一下关键代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        MyObjectA *objA = [[MyObjectA alloc] init];</span><br><span class="line">        MyObjectA *objB = [[MyObjectA alloc] init];</span><br><span class="line">        [objA addressOfSelector_myTest1];</span><br><span class="line">        [objB addressOfSelector_myTest1];</span><br><span class="line">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//methodForSelector:方法，让我们可以获取到方法的指针</span></span><br><span class="line">        <span class="comment">//示例1：</span></span><br><span class="line">        MyObjectA *objA = [[MyObjectA alloc] init];</span><br><span class="line">        MyObjectA *objB = [[MyObjectA alloc] init];</span><br><span class="line">        SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"addressOfSelector_myTest1"</span>);</span><br><span class="line">        IMP impA = [objA methodForSelector:sel];</span><br><span class="line">        IMP impB = [objB methodForSelector:sel];</span><br><span class="line">        impA();</span><br><span class="line">        impB();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//示例2：c的方式</span></span><br><span class="line">        <span class="keyword">void</span> (*setter)(<span class="keyword">int</span>, <span class="built_in">BOOL</span>, SEL);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        </span><br><span class="line">        setter = (<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="built_in">BOOL</span>, SEL))[objA methodForSelector:<span class="keyword">@selector</span>(addressOfSelector_myTest1)];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++)&#123;</span><br><span class="line">            setter(i, <span class="literal">YES</span>,<span class="keyword">@selector</span>(addressOfSelector_myTest1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：此处原文如下<br>原文开始》》》》<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; void <span class="comment">(*setter)(id, SEL, BOOL);</span><br><span class="line">&gt; int i;</span><br><span class="line">&gt; </span><br><span class="line">&gt; setter = (void (*)</span>(id, SEL, BOOL))[target methodForSelector:@<span class="keyword">selector</span>(setFilled:)];</span><br><span class="line">&gt; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++)</span><br><span class="line">&gt;     setter(targetList[i], @<span class="keyword">selector</span>(setFilled:), YES);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的就是函数指针的前两个参数必须是id和SEL。</p>
<p>《《《《原文结束</p>
<p>但经过实测，并不这样，求解释</p>
</blockquote>
<h3 id="四、消息转发">四、消息转发</h3><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([self respondsToSelector:@selector(<span class="keyword">method</span>)]) &#123;</span><br><span class="line">    [self performSelector:@selector(<span class="keyword">method</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，我们这边想讨论下不使用respondsToSelector:判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[<span class="type">SUTRuntimeMethod</span> <span class="keyword">method</span>]: unrecognized selector sent to instance <span class="number">0x100111940</span></span><br><span class="line">*** <span class="type">Terminating</span> app due to uncaught exception '<span class="type">NSInvalidArgumentException</span>', reason: '-[<span class="type">SUTRuntimeMethod</span> <span class="keyword">method</span>]: unrecognized selector sent to instance <span class="number">0x100111940</span>'</span><br></pre></td></tr></table></figure>
<p>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h4 id="1、动态方法解析">1、动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法:</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="params">(BOOL)</span>resolveClassMethod:<span class="params">(SEL)</span>sel;<span class="comment">//sel为  实例方法</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">+ <span class="params">(BOOL)</span>resolveInstanceMethod:<span class="params">(SEL)</span>sel;<span class="comment">//sel为 类方法</span></span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们有机会为该未知消息新增一个“处理方法”。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：<br>MyObjectA.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyObjectA.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectA.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectA</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> functionForInstanceMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self：%@, _cmd地址：%p"</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:<span class="string">@"instanceMethord1"</span>]) &#123;</span><br><span class="line">        SEL newSel = <span class="built_in">NSSelectorFromString</span>(selString);</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, newSel, (IMP)functionForInstanceMethod1,  <span class="string">"@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectA.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObjectA *objA = [[MyObjectA alloc] init];</span><br><span class="line">        SEL selA = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"instanceMethord1"</span>);</span><br><span class="line">        [objA performSelector:selA];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这种方案更多的是为了实现@dynamic属性。</p>
<h4 id="2、备用接收者">2、备用接收者</h4><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(id)</span>forwardingTargetForSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector</span></span><br></pre></td></tr></table></figure>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<p>MyObjectB.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectB</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>MyObjectB.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectB.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectBHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里很有趣，注释掉.h文件中的方法声明，照样执行</span></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethord2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectBHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethord2 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"MyObjectBHelper---self：%@, _cmd地址：%p"</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectB</span></span>&#123;</span><br><span class="line">    MyObjectBHelper *_helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        _helper = [[MyObjectBHelper alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将消息转发给_helper来处理</span></span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"instanceMethord2"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> _helper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectB.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObjectB *objB = [[MyObjectB alloc] init];</span><br><span class="line">        SEL selB = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"instanceMethord2"</span>);</span><br><span class="line">        [objB performSelector:selB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="3、完整消息转发">3、完整消息转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>forwardInvocation:<span class="params">(<span class="variable">NSInvocation</span> *)</span>anInvocation</span></span><br></pre></td></tr></table></figure>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象。</p>
<p>forwardInvocation:方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">NSMethodSignature</span> *)</span>methodSignatureForSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector</span></span><br></pre></td></tr></table></figure>
<p>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</p>
<p>完整的示例如下所示：</p>
<p>MyObjectC.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectC</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyObjectC.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectC.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectCHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里很有趣，注释掉.h文件中的方法声明，照样执行</span></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethord3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectCHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethord3 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyObjectCHelper---self：%@, _cmd地址：%p"</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectC</span> </span>&#123;</span><br><span class="line">    MyObjectCHelper *_helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        _helper = [[MyObjectCHelper alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([MyObjectCHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature = [MyObjectCHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看看signature中的内容</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> argCount = [signature numberOfArguments];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span> ; i&lt;argCount ; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ArgumentTypeAtIndex：%ld is %s"</span> , i,[signature getArgumentTypeAtIndex:i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"returnType:%s ,returnLen:%ld"</span> , [signature methodReturnType] , [signature methodReturnLength]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"signature:%@"</span> , signature);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([MyObjectCHelper instancesRespondToSelector:anInvocation<span class="variable">.selector</span>]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectC.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObjectC *objC = [[MyObjectC alloc] init];</span><br><span class="line">        SEL selC = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"instanceMethord3"</span>);</span><br><span class="line">        [objC performSelector:selC];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1、补充知识点：NSMethodSignature">3-1、补充知识点：NSMethodSignature</h5><p>NSMethodSignature顾名思义应该就是“方法签名”，类似于C++中的编译器时的函数签名。<br>官方定义该类为对方法的参数、返回类似进行封装，协同NSInvocation实现消息转发。</p>
<p>运行上面示例，打印signature中的内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArgumentTypeAtIndex：<span class="number">0</span> is @</span><br><span class="line">ArgumentTypeAtIndex：<span class="number">1</span> <span class="string">is :</span></span><br><span class="line"><span class="string">returnType:</span>v ,<span class="string">returnLen:</span><span class="number">0</span></span><br><span class="line"><span class="string">signature:</span>&lt;<span class="string">NSMethodSignature:</span> <span class="number">0x100114f90</span>&gt;</span><br></pre></td></tr></table></figure>
<p>@、:、v 这些奇怪的符号为Objective-C类型编码，含义如下：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>i</td>
<td>int</td>
</tr>
<tr>
<td>s</td>
<td>short</td>
</tr>
<tr>
<td>l</td>
<td>long ，在64位程序中，l为32位。</td>
</tr>
<tr>
<td>q</td>
<td>long long</td>
</tr>
<tr>
<td>C</td>
<td>unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
</tr>
<tr>
<td>B</td>
<td>C++标准的bool或者C99标准的_Bool</td>
</tr>
<tr>
<td>v</td>
<td>void</td>
</tr>
<tr>
<td>*</td>
<td>字符串（char *）</td>
</tr>
<tr>
<td>@</td>
<td>对象（无论是静态指定的还是通过id引用的）</td>
</tr>
<tr>
<td>#</td>
<td>类（Class）</td>
</tr>
<tr>
<td>:</td>
<td>方法选标（SEL）</td>
</tr>
<tr>
<td>[array type]</td>
<td>数组</td>
</tr>
<tr>
<td>{name=type…}</td>
<td>结构体</td>
</tr>
<tr>
<td>(name=type…)</td>
<td>联合体</td>
</tr>
<tr>
<td>bnum</td>
<td>num个bit的位域</td>
</tr>
<tr>
<td>^type</td>
<td>type类型的指针</td>
</tr>
<tr>
<td>?</td>
<td>未知类型（其它时候，一般用来指函数指针）</td>
</tr>
</tbody>
</table>
<h5 id="3-2、补充知识点：NSInvocation">3-2、补充知识点：NSInvocation</h5><p>在 iOS中可以直接调用某个对象的消息方式有2种:<br>第一种方式是使用NSObject类提供的performSelector系列方法,<br>还有一种方式就是使用NSInvocation进行动态运行时的消息分发。</p>
<p>MyObjectD.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectD</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyObjectD.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectD.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectDHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里很有趣，注释掉.h文件中的方法声明，照样执行</span></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethord4WithString:(<span class="built_in">NSString</span> *)str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectDHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)instanceMethord4WithString:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyObjectDHelper---self：%@, _cmd地址：%p,---str:%@"</span>, <span class="keyword">self</span>, _cmd,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectD</span></span>&#123;</span><br><span class="line">    MyObjectDHelper *_helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        _helper = [[MyObjectDHelper alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([MyObjectDHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature = [MyObjectDHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([MyObjectDHelper instancesRespondToSelector:anInvocation<span class="variable">.selector</span>]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"MyObjectD.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> testClassMethodUse<span class="built_in">NSInvocation</span>() &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化NSMethodSignature对象</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *sig = [<span class="built_in">NSString</span> methodSignatureForSelector:<span class="keyword">@selector</span>(stringWithString:)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化NSInvocation对象</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置执行目标对象</span></span><br><span class="line">    [invocation setTarget:[<span class="built_in">NSString</span> class]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置执行的selector</span></span><br><span class="line">    [invocation setSelector:<span class="keyword">@selector</span>(stringWithString:)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置参数</span></span><br><span class="line">    <span class="built_in">NSString</span> *argString = <span class="string">@"test method"</span>;</span><br><span class="line">    [invocation setArgument:&amp;argString atIndex:<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行方法</span></span><br><span class="line">    [invocation retainArguments];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取返回值</span></span><br><span class="line">    [invocation getReturnValue:&amp;string];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行结果 ====%@"</span>,string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> testInstanceMethodUse<span class="built_in">NSInvocation</span>()&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"我是一个string"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1=%@"</span>,string);</span><br><span class="line">    SEL subStringSel = <span class="keyword">@selector</span>(substringFromIndex:);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化NSMethodSignature对象</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [[<span class="built_in">NSString</span> class] instanceMethodSignatureForSelector:subStringSel];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化NSInvocation对象</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *myInvocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSignature];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置target</span></span><br><span class="line">    [myInvocation setTarget:string];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置selector</span></span><br><span class="line">    [myInvocation setSelector:subStringSel];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置参数</span></span><br><span class="line">    <span class="keyword">int</span> arg1 =  <span class="number">2</span>;</span><br><span class="line">    [myInvocation setArgument:&amp;arg1 atIndex:<span class="number">2</span>];<span class="comment">//参数从2开始，index 为0表示target，1为_cmd</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="built_in">NSString</span> *resultString = <span class="literal">nil</span>;</span><br><span class="line">    [myInvocation invoke];</span><br><span class="line">    [myInvocation getReturnValue:&amp;resultString];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2=%@"</span>,resultString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObjectD *objD = [[MyObjectD alloc] init];</span><br><span class="line">        <span class="built_in">NSString</span> *myString = <span class="string">@"1234567890"</span>;</span><br><span class="line">        SEL selD = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"instanceMethord4WithString:"</span>);</span><br><span class="line">        [objD performSelector:selD withObject:myString];</span><br><span class="line">        </span><br><span class="line">        testClassMethodUse<span class="built_in">NSInvocation</span>();</span><br><span class="line">        testInstanceMethodUse<span class="built_in">NSInvocation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h4 id="4、消息转发与多重继承">4、消息转发与多重继承</h4><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：</p>
<ul>
<li>多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；</li>
<li>而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</li>
</ul>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如respondsToSelector:和isKindOfClass:只能用于继承体系，而不能用于转发链。如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector])</span><br><span class="line"><span class="command">        return</span> YES;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        /* Here, test whether <span class="keyword">the</span> aSelector message can     *</span><br><span class="line">         * be forwarded <span class="keyword">to</span> another object <span class="keyword">and</span> whether <span class="keyword">that</span>  *</span><br><span class="line">         * object can respond <span class="keyword">to</span> <span class="keyword">it</span>. Return YES <span class="keyword">if</span> <span class="keyword">it</span> can.  */</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command"></span><br><span class="line">    return</span> NO;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、小结">5、小结</h4><p>在此，我们已经了解了Runtime中消息发送和转发的基本机制。这也是Runtime的强大之处，通过它，我们可以为程序增加很多动态的行为，虽然我们在实际开发中很少直接使用这些机制(如直接调用objc_msgSend)，但了解它们有助于我们更多地去了解底层的实现。其实在实际的编码过程中，我们也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。</p>
<h2 id="第六部分：RunTime-Method_Swizzling">第六部分：RunTime-Method Swizzling</h2><p>理解Method Swizzling是学习runtime机制的一个很好的机会。在此不多做整理，仅翻译由Mattt Thompson发表于nshipster的<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>一文。</p>
<p>Method Swizzling是改变一个selector的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中selector对应的函数，来修改方法的实现。</p>
<p>例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p>
<p>这种情况下，我们就可以使用Method Swizzling，如在代码所示</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIViewController+Tracking.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [<span class="keyword">self</span> class];</span><br><span class="line">        <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">        <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod =</span><br><span class="line">        class_addMethod(class,</span><br><span class="line">                        originalSelector,</span><br><span class="line">                        method_getImplementation(swizzledMethod),</span><br><span class="line">                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Method Swizzling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@":) :) :) :)viewWillAppear: %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们通过method swizzling修改了UIViewController的@selector(viewWillAppear:)对应的函数指针，使其实现指向了我们自定义的xxx_viewWillAppear的实现。这样，当UIViewController及其子类的对象调用viewWillAppear时，都会打印一条日志信息。</p>
<h3 id="一、method_swizzling注意事项">一、method swizzling注意事项</h3><p>上面的例子很好地展示了使用method swizzling来一个类中注入一些我们新的操作。当然，还有许多场景可以使用method swizzling，在此不多举例。在此我们说说使用method swizzling需要注意的一些问题：</p>
<h4 id="1、Swizzling应该总是在+load中执行">1、Swizzling应该总是在+load中执行</h4><p>在Objective-C中，运行时会自动调用每个类的两个方法：</p>
<ul>
<li><code>+load</code>会在类初始加载时调用</li>
<li><code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用</li>
</ul>
<p>这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<h4 id="2、Swizzling应该总是在dispatch_once中执行">2、Swizzling应该总是在dispatch_once中执行</h4><p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>
<h4 id="3、选择器、方法与实现">3、选择器、方法与实现</h4><p>在Objective-C中，选择器(selector)、方法(method)和实现(implementation)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>
<p>以下是Objective-C Runtime Reference中的对这几个术语一些描述：</p>
<ol>
<li>Selector(typedef struct objc_selector *SEL)：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>
<li>Method(typedef struct objc_method *Method)：在类定义中表示方法的类型</li>
<li>Implementation(typedef id (*IMP)(id, SEL, …))：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>
</ol>
<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>
<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</p>
<h4 id="4、调用_cmd">4、调用_cmd</h4><p>我们回过头来看看前面新的方法的实现代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。</p>
<h4 id="5、注意事项小结">5、注意事项小结</h4><p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>
<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看<objc runtime.h="">头文件以了解事件是如何发生的。</objc></li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>
<h3 id="二、Method_Swizzling_原理">二、Method Swizzling 原理</h3><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>
<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">SelectorA<span class="comment">--&gt;IMPa</span></span><br><span class="line">SelectorB<span class="comment">--&gt;IMPb</span></span><br><span class="line">SelectorC<span class="comment">--&gt;IMPc</span></span><br></pre></td></tr></table></figure>
<p>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，</p>
<p>我们可以利用 class_replaceMethod 来修改类，</p>
<p>我们可以利用 method_setImplementation 来直接设置某个方法的IMP，</p>
<p>……</p>
<p>归根结底，都是偷换了selector的IMP，如下图所示：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">SelectorA<span class="comment">--&gt;IMPa</span></span><br><span class="line">SelectorB<span class="comment">--&gt;IMPb</span></span><br><span class="line">SelectorC<span class="comment">--&gt;IMPn</span></span><br><span class="line">SelectorN<span class="comment">--&gt;IMPc</span></span><br></pre></td></tr></table></figure>
<p>举个例子好了，我想钩一下NSArray的lastObject 方法，只需两个步骤。<br>第一步：给NSArray加一个我自己的lastObject</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSArray+Swizzle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">Swizzle</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)myLastObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> ret = [<span class="keyword">self</span> myLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"**********  myLastObject *********** "</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>乍一看，这不递归了么？别忘记这是我们准备调换IMP的selector，[self myLastObject] 将会执行真的 [self lastObject] 。</p>
<p>第二步：调换IMP</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"NSArray+Swizzle.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Method ori_Method =  class_getInstanceMethod([<span class="built_in">NSArray</span> class], <span class="keyword">@selector</span>(lastObject));</span><br><span class="line">        Method my_Method = class_getInstanceMethod([<span class="built_in">NSArray</span> class], <span class="keyword">@selector</span>(myLastObject));</span><br><span class="line">        method_exchangeImplementations(ori_Method, my_Method);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSArray</span> *array = @[<span class="string">@"0"</span>,<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *string = [array lastObject];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"TEST RESULT : %@"</span>,string);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、Method_Swizzling_的封装">三、Method Swizzling 的封装</h3><p>之前在github上找到的RNSwizzle，推荐给大家，可以搜一下。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  RNSwizzle.m  </span></span><br><span class="line"><span class="comment">//  MethodSwizzle  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">#</span><span class="built_in">import</span> <span class="string">"RNSwizzle.h"</span>  </span><br><span class="line"><span class="built_in">#</span><span class="built_in">import</span>   </span><br><span class="line">@implementation NSObject <span class="params">(RNSwizzle)</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">+ <span class="params">(IMP)</span>swizzleSelector:<span class="params">(SEL)</span>origSelector   </span><br><span class="line">               withIMP:<span class="params">(IMP)</span>newIMP &#123;  </span><br><span class="line">  Class class = [self class];  </span><br><span class="line">  Method origMethod = class_getInstanceMethod<span class="params">(class,  </span><br><span class="line">                                              origSelector)</span>;  </span><br><span class="line">  IMP origIMP = method_getImplementation<span class="params">(origMethod)</span>;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span><span class="params">(!class_addMethod<span class="params">(self, origSelector, newIMP,  </span><br><span class="line">                      method_getTypeEncoding<span class="params">(origMethod)</span>)</span>)</span>  </span><br><span class="line">  &#123;  </span><br><span class="line">    method_setImplementation<span class="params">(origMethod, newIMP)</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  return origIMP;  </span><br><span class="line">&#125;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="四、Method_Swizzling_危险不危险">四、Method Swizzling 危险不危险</h3><p>针对这个问题，我在<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">stackoverflow</a>上看到了满意的答案，这里翻译一下，总结记录在本文中，以示分享：</p>
<p>使用 Method Swizzling 编程就好比切菜时使用锋利的刀，一些人因为担心切到自己所以害怕锋利的刀具，可是事实上，使用钝刀往往更容易出事，而利刀更为安全。<br>Method swizzling 可以帮助我们写出更好的，更高效的，易维护的代码。但是如果滥用它，也将会导致难以排查的bug。 </p>
<p>背景</p>
<p>好比设计模式，如果我们摸清了一个模式的门道，使用该模式与否我们自己心里有数。单例模式就是一个很好的例子，它饱受争议但是许多人依旧使用它。Method Swizzling也是一样，一旦你真正理解它的优势和弊端，使用它与否你应该就有你自己的观点。</p>
<p>讨论</p>
<p>这里是一些 Method Swizzling的陷阱：</p>
<ol>
<li>Method swizzling is not atomic</li>
<li>Changes behavior of un-owned code</li>
<li>Possible naming conflicts</li>
<li>Swizzling changes the method’s arguments</li>
<li>The order of swizzles matters</li>
<li>Difficult to understand (looks recursive)</li>
<li>Difficult to debug</li>
</ol>
<p>我将逐一分析这些点，增进对Method Swizzling的理解的同时，并搞懂如何应对。</p>
<h5 id="1、Method_swizzling_is_not_atomic">1、Method swizzling is not atomic</h5><p>我所见过的使用method swizzling实现的方法在并发使用时基本都是安全的。95%的情况里这都不会是个问题。通常你替换一个方法的实现，是希望它在整个程序的生命周期里有效的。也就是说，你会把 method swizzling 修改方法实现的操作放在一个加号方法 +(void)load里，并在应用程序的一开始就调用执行。你将不会碰到并发问题。假如你在 +(void)initialize初始化方法中进行swizzle，那么……rumtime可能死于一个诡异的状态。</p>
<h5 id="2、Changes_behavior_of_un-owned_code">2、Changes behavior of un-owned code</h5><p>这是swizzling的一个问题。我们的目标是改变某些代码。swizzling方法是一件灰常灰常重要的事，当你不只是对一个NSButton类的实例进行了修改，而是程序中所有的NSButton实例。因此在swizzling时应该多加小心，但也不用总是去刻意避免。</p>
<p>想象一下，如果你重写了一个类的方法，而且没有调用父类的这个方法，这可能会引起问题。大多数情况下，父类方法期望会被调用（至少文档是这样说的）。如果你在swizzling实现中也这样做了，这会避免大部分问题。还是调用原始实现吧，如若不然，你会费很大力气去考虑代码的安全问题。</p>
<h5 id="3、Possible_naming_conflicts">3、Possible naming conflicts</h5><p>命名冲突贯穿整个Cocoa的问题. 我们常常在类名和类别方法名前加上前缀。不幸的是，命名冲突仍是个折磨。但是swizzling其实也不必过多考虑这个问题。我们只需要在原始方法命名前做小小的改动来命名就好，比如通常我们这样命名：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">NSView </span>: NSObject  </span><br><span class="line">- (void)<span class="attribute">setFrame</span>:(NSRect)frame;  </span><br><span class="line"><span class="variable">@end</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="variable">@implementation</span> NSView (MyViewAdditions)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- (void)<span class="attribute">my_setFrame</span>:(NSRect)frame &#123;  </span><br><span class="line">    <span class="comment">// do custom work  </span></span><br><span class="line">    <span class="attr_selector">[self my_setFrame:frame]</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">+ (void)load &#123;  </span><br><span class="line">    <span class="attr_selector">[self swizzle:@selector(setFrame:) with:@selector(my_setFrame:)]</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>这段代码运行正确，但是如果my_setFrame: 在别处被定义了会发生什么呢？<br>这个问题不仅仅存在于swizzling，这里有一个替代的变通方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSView</span> (<span class="title">MyViewAdditions</span>)  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> MySetFrame(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSRect</span> frame);  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> (*SetFrameIMP)(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSRect</span> frame);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> MySetFrame(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSRect</span> frame) &#123;  </span><br><span class="line">    <span class="comment">// do custom work  </span></span><br><span class="line">    SetFrameIMP(<span class="keyword">self</span>, _cmd, frame);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;  </span><br><span class="line">    [<span class="keyword">self</span> swizzle:<span class="keyword">@selector</span>(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>看起来不那么Objectice-C了（用了函数指针），这样避免了selector的命名冲突。</p>
<p>最后给出一个较完美的swizzle方法的定义：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">IMP</span> *<span class="type">IMPPointer</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">BOOL</span> class_swizzleMethodAndStore(<span class="type">Class</span> class, <span class="type">SEL</span> original, <span class="type">IMP</span> replacement, <span class="type">IMPPointer</span> store) &#123;  </span><br><span class="line">    <span class="type">IMP</span> imp = <span class="type">NULL</span>;  </span><br><span class="line">    <span class="type">Method</span> <span class="keyword">method</span> = class_getInstanceMethod(class, original);  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">method</span>) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *<span class="keyword">type</span> = method_getTypeEncoding(<span class="keyword">method</span>);  </span><br><span class="line">        imp = class_replaceMethod(class, original, replacement, <span class="keyword">type</span>);  </span><br><span class="line">        <span class="keyword">if</span> (!imp) &#123;  </span><br><span class="line">            imp = method_getImplementation(<span class="keyword">method</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (imp &amp;&amp; store) &#123; *store = imp; &#125;  </span><br><span class="line">    <span class="keyword">return</span> (imp != <span class="type">NULL</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">@implementation <span class="type">NSObject</span> (<span class="type">FRRuntimeAdditions</span>)  </span><br><span class="line">+ (<span class="type">BOOL</span>)swizzle:(<span class="type">SEL</span>)original <span class="keyword">with</span>:(<span class="type">IMP</span>)replacement store:(<span class="type">IMPPointer</span>)store &#123;  </span><br><span class="line">    <span class="keyword">return</span> class_swizzleMethodAndStore(self, original, replacement, store);  </span><br><span class="line">&#125;  </span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="4、Swizzling_changes_the_method’s_arguments">4、Swizzling changes the method’s arguments</h5><p>我认为这是最大的问题。想正常调用method swizzling 将会是个问题。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[self my_setFrame:frame]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>直接调用<code>my_setFrame:</code> ， runtime做的是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend<span class="list">(<span class="keyword">self</span>, @selector<span class="list">(<span class="keyword">my_setFrame</span>:)</span>, frame)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>runtime去寻找my_setFrame:的方法实现, _cmd参数为 my_setFrame: ，但是事实上runtime找到的方法实现是原始的 setFrame: 的。</p>
<p>一个简单的解决办法：使用上面介绍的swizzling定义。  </p>
<h5 id="5、The_order_of_swizzles_matters">5、The order of swizzles matters</h5><p>多个swizzle方法的执行顺序也需要注意。假设 setFrame: 只定义在NSView中，想像一下按照下面的顺序执行：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NSButton <span class="string">swizzle:</span><span class="annotation">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="annotation">@selector</span>(<span class="string">my_buttonSetFrame:</span>)];  </span><br><span class="line">[NSControl <span class="string">swizzle:</span><span class="annotation">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="annotation">@selector</span>(<span class="string">my_controlSetFrame:</span>)];  </span><br><span class="line">[NSView <span class="string">swizzle:</span><span class="annotation">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="annotation">@selector</span>(<span class="string">my_viewSetFrame:</span>)];</span><br></pre></td></tr></table></figure>
<p>What happens when the method on NSButton is swizzled? Well most swizzling will ensure that it’s not replacing the implementation of setFrame: for all views, so it will pull up the instance method. This will use the existing implementation to re-define setFrame: in the NSButton class so that exchanging implementations doesn’t affect all views. The existing implementation is the one defined on NSView. The same thing will happen when swizzling on NSControl (again using the NSView implementation).</p>
<p>When you call setFrame: on a button, it will therefore call your swizzled method, and then jump straight to the setFrame: method originally defined on NSView. The NSControl and NSView swizzled implementations will not be called.</p>
<p>But what if the order were:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NSView <span class="string">swizzle:</span><span class="annotation">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="annotation">@selector</span>(<span class="string">my_viewSetFrame:</span>)];  </span><br><span class="line">[NSControl <span class="string">swizzle:</span><span class="annotation">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="annotation">@selector</span>(<span class="string">my_controlSetFrame:</span>)];  </span><br><span class="line">[NSButton <span class="string">swizzle:</span><span class="annotation">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="annotation">@selector</span>(<span class="string">my_buttonSetFrame:</span>)];</span><br></pre></td></tr></table></figure>
<p>Since the view swizzling takes place first, the control swizzling will be able to pull up the right method. Likewise, since the control swizzling was before the button swizzling, the button will pull up the control’s swizzled implementation of setFrame:. This is a bit confusing, but this is the correct order. How can we ensure this order of things?</p>
<p>Again, just use load to swizzle things. If you swizzle in load and you only make changes to the class being loaded, you’ll be safe. The load method guarantees that the super class load method will be called before any subclasses. We’ll get the exact right order!</p>
<p>这段贴了原文，硬翻译太拗口……总结一下就是：<del>多个有继承关系的类的对象swizzle时，从子类对象开始 。 如果先swizzle父类对象，那么后面子类对象swizzle时就无法拿到真正的原始方法实现了。</del> </p>
<p>（感谢评论中 qq373127202 的提醒，在此更正一下，十分感谢）<br>多个有继承关系的类的对象swizzle时，先从父对象开始。 这样才能保证子类方法拿到父类中的被swizzle的实现。在+(void)load中swizzle不会出错，就是因为load类方法会默认从父类开始调用。  </p>
<h5 id="6、Difficult_to_understand_(looks_recursive)">6、Difficult to understand (looks recursive)</h5><p>（新方法的实现）看起来像递归，但是看看上面已经给出的 swizzling 封装方法, 使用起来就很易读懂.<br>这个问题是已完全解决的了！</p>
<h5 id="7、Difficult_to_debug">7、Difficult to debug</h5><p>debug时打出的backtrace，其中掺杂着被swizzle的方法名，一团糟啊！上面介绍的swizzle方案，使backtrace中打印出的方法名还是很清晰的。但仍然很难去debug，因为很难记住swizzling影响过什么。给你的代码写好文档（即使只有你一个人会看到）。养成一个好习惯，不会比调试多线程问题还难的。</p>
<h2 id="第七部分：RunTime-协议与分类">第七部分：RunTime-协议与分类</h2><h3 id="一、基础数据类型-1">一、基础数据类型</h3><h4 id="1、Category">1、Category</h4><p>Category是表示一个指向分类的结构体的指针，其定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_category &#123;</span><br><span class="line">    <span class="keyword">char</span> *category_name                          OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 分类名</span></span><br><span class="line">    <span class="keyword">char</span> *class_name                             OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 分类所属的类名</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods    OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *class_methods       OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols         OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。</p>
<h4 id="2、Protocol">2、Protocol</h4><p>Protocol的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，Protocol其中实就是一个对象结构体。</p>
<h3 id="二、操作函数">二、操作函数</h3><p>Runtime并没有在<objc runtime.h="">头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在objc_class中，我们可以通过针对objc_class的操作函数来获取分类的信息。如下例所示：</objc></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"测试objc_class中的方法列表是否包含分类中的方法"</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        Method *methodList = class_copyMethodList(RuntimeCategoryClass<span class="variable">.class</span>, &amp;outCount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            Method method = methodList[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"RuntimeCategoryClass's method: %s"</span>, name);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"分类方法method2在objc_class的方法列表中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试objc_class中的方法列表是否包含分类中的方法</span><br><span class="line"><span class="type">RuntimeCategoryClass</span>'s <span class="keyword">method</span>: method1</span><br><span class="line">分类方法method2在objc_class的方法列表中</span><br><span class="line"><span class="type">RuntimeCategoryClass</span>'s <span class="keyword">method</span>: method2</span><br></pre></td></tr></table></figure>
<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议</span></span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议采用的协议</span></span><br><span class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>objc_getProtocol函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil。</p>
</li>
<li><p>objc_copyProtocolList函数，获取到的数组需要使用free来释放</p>
</li>
<li><p>objc_allocateProtocol函数，如果同名的协议已经存在，则返回nil</p>
</li>
<li><p>objc_registerProtocol函数，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议</p>
</li>
</ul>
<p>需要强调的是，协议一旦注册后就不可再修改，即无法再通过调用protocol_addMethodDescription、protocol_addProtocol和protocol_addProperty往协议中添加方法等。</p>
<p>小结</p>
<p>Runtime并没有提供过多的函数来处理分类。对于协议，我们可以动态地创建协议，并向其添加方法、属性及继承的协议，并在运行时动态地获取这些信息。</p>
<h2 id="第八部分：RunTime-拾遗">第八部分：RunTime-拾遗</h2><h3 id="一、super">一、super</h3><p>在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到super，如下所示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MyViewController</span>: UIViewController</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> MyViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="attr_selector">[super viewDidLoad]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>如何使用super我们都知道。现在的问题是，它是如何工作的呢？</p>
<p>首先我们需要知道的是super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123; id receiver; Class superClass; &#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体有两个成员：</p>
<ol>
<li>receiver：即消息的实际接收者</li>
<li>superClass：指针当前类的父类</li>
</ol>
<p>当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。</p>
<p>接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper ( <span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ... );</span><br></pre></td></tr></table></figure>
<p>该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&gt;receiver去调用这个selector，而此时的操作流程就是如下方式了</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend<span class="list">(<span class="keyword">objc_super-&gt;receiver</span>, @selector<span class="list">(<span class="keyword">viewDidLoad</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>由于objc_super-&gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend<span class="list">(<span class="keyword">self</span>, @selector<span class="list">(<span class="keyword">viewDidLoad</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>为了便于理解，我们看以下实例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class: %@"</span>, <span class="keyword">self</span><span class="variable">.class</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class: %@"</span>, <span class="keyword">super</span><span class="variable">.class</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用MyClass的test方法后，其输出是：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> <span class="class"><span class="keyword">class</span>: <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">super</span> <span class="class"><span class="keyword">class</span>: <span class="title">MyClass</span></span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看到，两者的输出都是MyClass。大家可以自行用上面介绍的内容来梳理一下。</p>
<h3 id="二、库相关操作">二、库相关操作</h3><p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的Objective-C框架和动态库的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyImageNames ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getImageName ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyClassNamesForImage ( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"获取指定类所在动态库"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UIView's Framework: %s"</span>, class_getImageName(<span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"获取指定库或框架中所有类的类名"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> ** classes = objc_copyClassNamesForImage(class_getImageName(<span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>)), &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, classes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>5 Runtile12-ku[<span class="number">16098:1482104</span>] 获取指定类所在动态库</span><br><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>5 Runtile12-ku[<span class="number">16098:1482104</span>] UIView's Framework: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>5 Runtile12-ku[<span class="number">16098:1482104</span>] 获取指定库或框架中所有类的类名</span><br><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>5 Runtile12-ku[<span class="number">16098:1482104</span>] class name: UIKeyboardPredictiveSettings</span><br><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>6 Runtile12-ku[<span class="number">16098:1482104</span>] class name: _UIPickerViewTopFrame</span><br><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>6 Runtile12-ku[<span class="number">16098:1482104</span>] class name: _UIOnePartImageView</span><br><span class="line"><span class="number">2015-08-13</span> <span class="number">20:38:05.86</span>6 Runtile12-ku[<span class="number">16098:1482104</span>] class name: _UIPickerViewSelectionBar</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="三、Block">三、Block</h3><p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span> <span class="params">( id block )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span> <span class="params">( IMP anImp )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span> <span class="params">( IMP anImp )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">MyRuntimeBlock :</span> NSObject</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br><span class="line"></span><br><span class="line"><span class="annotation">@implementation</span> MyRuntimeBlock</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">IMP imp = imp_implementationWithBlock(^(id obj, NSString *str) &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class_addMethod(MyRuntimeBlock.<span class="keyword">class</span>, <span class="annotation">@selector</span>(<span class="string">testBlock:</span>), imp, <span class="string">"v@:@"</span>);</span><br><span class="line"></span><br><span class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</span><br><span class="line">[runtime <span class="string">performSelector:</span><span class="annotation">@selector</span>(<span class="string">testBlock:</span>) <span class="string">withObject:</span>@<span class="string">"hello world!"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果是 2014-11-09 14:03:19.779 [1172:395446] hello world!</span></span><br></pre></td></tr></table></figure>
<h3 id="四、弱引用操作">四、弱引用操作</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载弱引用指针引用的对象并返回</span></span><br><span class="line"><span class="keyword">id</span> objc_loadWeak ( <span class="keyword">id</span> *location );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储__weak变量的新值</span></span><br><span class="line"><span class="keyword">id</span> objc_storeWeak ( <span class="keyword">id</span> *location, <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。</p>
</li>
<li><p>objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。</p>
</li>
</ul>
<p>这两个函数的具体实施在此不举例，有兴趣的小伙伴可以参考《Objective-C高级编程：iOS与OS X多线程和内存管理》中对__weak实现的介绍。</p>
<h3 id="五、宏定义">五、宏定义</h3><p>在runtime中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示BOOL值的YES/NO；而有些值不常用，如OBJC_ROOT_CLASS。在此我们做一个简单的介绍。</p>
<h4 id="1、布尔值">1、布尔值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine YES  (BOOL)<span class="number">1</span></span><br><span class="line"><span class="hexcolor">#def</span>ine NO   (BOOL)<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这两个宏定义定义了表示布尔值的常量，需要注意的是YES的值是1，而不是非0值。</p>
<h4 id="2、空值">2、空值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine nil  __DARWIN_NULL</span><br><span class="line"><span class="hexcolor">#def</span>ine Nil  __DARWIN_NULL</span><br></pre></td></tr></table></figure>
<p>其中nil用于空的实例对象，而Nil用于空类对象。</p>
<h4 id="3、分发函数原型">3、分发函数原型</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine OBJC_OLD_DISPATCH_PROTOTYPES  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换</p>
<h4 id="4、Objective-C根类">4、Objective-C根类</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine OBJC_ROOT_CLASS</span><br></pre></td></tr></table></figure>
<p>如果我们定义了一个Objective-C根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。</p>
<p>其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)</span><br><span class="line">OBJC_ROOT_CLASS</span><br><span class="line">OBJC_EXPORT</span><br><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以参考这种方式来定义我们自己的根类。</p>
<h4 id="5、局部变量存储时长">5、局部变量存储时长</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NS_VALID_UNTIL_END_OF_SCOPE</span><br></pre></td></tr></table></figure>
<p>该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。</p>
<p>我们将局部变量标记为id类型或者是指向ObjC对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。</p>
<h4 id="6、关联对象行为">6、关联对象行为</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_ASSIGN</span>  = <span class="number">0</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>  = <span class="number">1</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY_NONATOMIC</span>  = <span class="number">3</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN</span>  = <span class="number">01401</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY</span>  = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这几个值在前面已介绍过，在此不再重复。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RunTime/" rel="tag">#RunTime</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/08/10/自定义UICollectionViewLayout（一）/" rel="prev">自定义UICollectionViewLayout（一）UICollectionViewLayout Class Reference翻译</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/25/2015-07-Git使用/" rel="next">Git使用入门</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div id="disqus_thread">
                    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/avatar.png" alt="YL" itemprop="image"/>
          <p class="site-author-name" itemprop="name">YL</p>
        </div>
        <p class="site-description motion-element" itemprop="description">IOS技术总结</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://aliang9585.github.io" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/ytlvy" target="_blank">Twitter</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://nshipster.com" target="_blank">NSHipster</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.mikeash.com/pyblog" target="_blank">NSBlog</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.objc.io" target="_blank">objcio</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.raywenderlich.com" target="_blank">raywenderlich</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分：初识RunTime"><span class="nav-number">1.</span> <span class="nav-text">第一部分：初识RunTime</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、示例代码"><span class="nav-number">1.1.</span> <span class="nav-text">1、示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、方法调用如何变成了消息发送"><span class="nav-number">1.2.</span> <span class="nav-text">2、方法调用如何变成了消息发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、理解对象的真实面目"><span class="nav-number">1.3.</span> <span class="nav-text">3、理解对象的真实面目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）NSObject"><span class="nav-number">1.3.1.</span> <span class="nav-text">（1）NSObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）Class"><span class="nav-number">1.3.2.</span> <span class="nav-text">（2）Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）objc_class"><span class="nav-number">1.3.3.</span> <span class="nav-text">（3）objc_class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）解释结构体objc_class的成员"><span class="nav-number">1.3.4.</span> <span class="nav-text">（4）解释结构体objc_class的成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、理解调用方法的实质"><span class="nav-number">1.4.</span> <span class="nav-text">4、理解调用方法的实质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二部分：RunTime解惑"><span class="nav-number">2.</span> <span class="nav-text">第二部分：RunTime解惑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Runtime_是什么？"><span class="nav-number">2.1.</span> <span class="nav-text">1、Runtime 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、Runtime_做什么？"><span class="nav-number">2.2.</span> <span class="nav-text">2、Runtime 做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、Modern_Runtime与Legacy_Runtime"><span class="nav-number">2.3.</span> <span class="nav-text">3、Modern Runtime与Legacy Runtime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、Selector"><span class="nav-number">2.4.</span> <span class="nav-text">4、Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、Message"><span class="nav-number">2.5.</span> <span class="nav-text">5、Message</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、Class、objc_class、objc_object"><span class="nav-number">2.6.</span> <span class="nav-text">6、Class、objc_class、objc_object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、objc_cache"><span class="nav-number">2.7.</span> <span class="nav-text">7、objc_cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、元类(Meta_Class)"><span class="nav-number">2.8.</span> <span class="nav-text">8、元类(Meta Class)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三部分：RunTime-类与对象操作函数"><span class="nav-number">3.</span> <span class="nav-text">第三部分：RunTime-类与对象操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、类相关操作函数"><span class="nav-number">3.1.</span> <span class="nav-text">一、类相关操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、类名"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、类名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、父类(super_class)和元类(meta-class)"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、父类(super_class)和元类(meta-class)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、实例变量大小(instance_size)"><span class="nav-number">3.1.3.</span> <span class="nav-text">3、实例变量大小(instance_size)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、成员变量(ivars)及属性"><span class="nav-number">3.1.4.</span> <span class="nav-text">4、成员变量(ivars)及属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、方法(methodLists)"><span class="nav-number">3.1.5.</span> <span class="nav-text">5、方法(methodLists)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、协议(objc_protocol_list)"><span class="nav-number">3.1.6.</span> <span class="nav-text">5、协议(objc_protocol_list)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、版本(version)"><span class="nav-number">3.1.7.</span> <span class="nav-text">6、版本(version)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、其它"><span class="nav-number">3.1.8.</span> <span class="nav-text">7、其它</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、Example"><span class="nav-number">3.1.9.</span> <span class="nav-text">8、Example</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、动态创建类和对象"><span class="nav-number">3.2.</span> <span class="nav-text">二、动态创建类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、动态创建类"><span class="nav-number">3.2.1.</span> <span class="nav-text">1、动态创建类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：Method_与_IMP"><span class="nav-number">3.2.2.</span> <span class="nav-text">补充：Method 与 IMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、动态创建对象"><span class="nav-number">3.2.3.</span> <span class="nav-text">2、动态创建对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、实例操作函数"><span class="nav-number">3.3.</span> <span class="nav-text">三、实例操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-针对整个对象进行操作的函数，这类函数包含"><span class="nav-number">3.3.1.</span> <span class="nav-text">1.针对整个对象进行操作的函数，这类函数包含</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-针对对象实例变量进行操作的函数，这类函数包含："><span class="nav-number">3.3.2.</span> <span class="nav-text">2.针对对象实例变量进行操作的函数，这类函数包含：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-针对对象的类进行操作的函数，这类函数包含："><span class="nav-number">3.3.3.</span> <span class="nav-text">3.针对对象的类进行操作的函数，这类函数包含：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、获取类定义"><span class="nav-number">3.4.</span> <span class="nav-text">四、获取类定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四部分：RunTime-成员变量与属性"><span class="nav-number">4.</span> <span class="nav-text">第四部分：RunTime-成员变量与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、类型编码(Type_Encoding)"><span class="nav-number">4.1.</span> <span class="nav-text">一、类型编码(Type Encoding)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Category的关联对象、成员变量、属性"><span class="nav-number">4.2.</span> <span class="nav-text">二、Category的关联对象、成员变量、属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、基础数据类型"><span class="nav-number">4.2.1.</span> <span class="nav-text">1、基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ivar"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc_property_t"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">objc_property_t</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc_property_attribute_t"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">objc_property_attribute_t</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、关联对象(Associated_Object)"><span class="nav-number">4.2.2.</span> <span class="nav-text">2、关联对象(Associated Object)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、成员变量、属性的操作方法"><span class="nav-number">4.2.3.</span> <span class="nav-text">3、成员变量、属性的操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）成员变量"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">（1）成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）关联对象"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">（2）关联对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）属性"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">（3）属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、示例"><span class="nav-number">4.2.4.</span> <span class="nav-text">4、示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五部分：RunTime-消息发送及消息转发"><span class="nav-number">5.</span> <span class="nav-text">第五部分：RunTime-消息发送及消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基础数据类型"><span class="nav-number">5.1.</span> <span class="nav-text">一、基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、SEL"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、SEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、IMP"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、IMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、Method"><span class="nav-number">5.1.3.</span> <span class="nav-text">3、Method</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、方法相关操作函数"><span class="nav-number">5.2.</span> <span class="nav-text">二、方法相关操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、方法"><span class="nav-number">5.2.1.</span> <span class="nav-text">1、方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、方法选择器"><span class="nav-number">5.2.2.</span> <span class="nav-text">2、方法选择器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、方法调用流程"><span class="nav-number">5.3.</span> <span class="nav-text">三、方法调用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、流程"><span class="nav-number">5.3.1.</span> <span class="nav-text">1、流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、隐藏参数"><span class="nav-number">5.3.2.</span> <span class="nav-text">2、隐藏参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、获取方法地址"><span class="nav-number">5.3.3.</span> <span class="nav-text">3、获取方法地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、消息转发"><span class="nav-number">5.4.</span> <span class="nav-text">四、消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、动态方法解析"><span class="nav-number">5.4.1.</span> <span class="nav-text">1、动态方法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、备用接收者"><span class="nav-number">5.4.2.</span> <span class="nav-text">2、备用接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、完整消息转发"><span class="nav-number">5.4.3.</span> <span class="nav-text">3、完整消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1、补充知识点：NSMethodSignature"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">3-1、补充知识点：NSMethodSignature</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2、补充知识点：NSInvocation"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">3-2、补充知识点：NSInvocation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、消息转发与多重继承"><span class="nav-number">5.4.4.</span> <span class="nav-text">4、消息转发与多重继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、小结"><span class="nav-number">5.4.5.</span> <span class="nav-text">5、小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六部分：RunTime-Method_Swizzling"><span class="nav-number">6.</span> <span class="nav-text">第六部分：RunTime-Method Swizzling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、method_swizzling注意事项"><span class="nav-number">6.1.</span> <span class="nav-text">一、method swizzling注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、Swizzling应该总是在+load中执行"><span class="nav-number">6.1.1.</span> <span class="nav-text">1、Swizzling应该总是在+load中执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、Swizzling应该总是在dispatch_once中执行"><span class="nav-number">6.1.2.</span> <span class="nav-text">2、Swizzling应该总是在dispatch_once中执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、选择器、方法与实现"><span class="nav-number">6.1.3.</span> <span class="nav-text">3、选择器、方法与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、调用_cmd"><span class="nav-number">6.1.4.</span> <span class="nav-text">4、调用_cmd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、注意事项小结"><span class="nav-number">6.1.5.</span> <span class="nav-text">5、注意事项小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Method_Swizzling_原理"><span class="nav-number">6.2.</span> <span class="nav-text">二、Method Swizzling 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、Method_Swizzling_的封装"><span class="nav-number">6.3.</span> <span class="nav-text">三、Method Swizzling 的封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、Method_Swizzling_危险不危险"><span class="nav-number">6.4.</span> <span class="nav-text">四、Method Swizzling 危险不危险</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Method_swizzling_is_not_atomic"><span class="nav-number">6.4.0.1.</span> <span class="nav-text">1、Method swizzling is not atomic</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Changes_behavior_of_un-owned_code"><span class="nav-number">6.4.0.2.</span> <span class="nav-text">2、Changes behavior of un-owned code</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Possible_naming_conflicts"><span class="nav-number">6.4.0.3.</span> <span class="nav-text">3、Possible naming conflicts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Swizzling_changes_the_method’s_arguments"><span class="nav-number">6.4.0.4.</span> <span class="nav-text">4、Swizzling changes the method’s arguments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、The_order_of_swizzles_matters"><span class="nav-number">6.4.0.5.</span> <span class="nav-text">5、The order of swizzles matters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、Difficult_to_understand_(looks_recursive)"><span class="nav-number">6.4.0.6.</span> <span class="nav-text">6、Difficult to understand (looks recursive)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、Difficult_to_debug"><span class="nav-number">6.4.0.7.</span> <span class="nav-text">7、Difficult to debug</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七部分：RunTime-协议与分类"><span class="nav-number">7.</span> <span class="nav-text">第七部分：RunTime-协议与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基础数据类型-1"><span class="nav-number">7.1.</span> <span class="nav-text">一、基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、Category"><span class="nav-number">7.1.1.</span> <span class="nav-text">1、Category</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、Protocol"><span class="nav-number">7.1.2.</span> <span class="nav-text">2、Protocol</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、操作函数"><span class="nav-number">7.2.</span> <span class="nav-text">二、操作函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八部分：RunTime-拾遗"><span class="nav-number">8.</span> <span class="nav-text">第八部分：RunTime-拾遗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、super"><span class="nav-number">8.1.</span> <span class="nav-text">一、super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、库相关操作"><span class="nav-number">8.2.</span> <span class="nav-text">二、库相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、Block"><span class="nav-number">8.3.</span> <span class="nav-text">三、Block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、弱引用操作"><span class="nav-number">8.4.</span> <span class="nav-text">四、弱引用操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、宏定义"><span class="nav-number">8.5.</span> <span class="nav-text">五、宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、布尔值"><span class="nav-number">8.5.1.</span> <span class="nav-text">1、布尔值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、空值"><span class="nav-number">8.5.2.</span> <span class="nav-text">2、空值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、分发函数原型"><span class="nav-number">8.5.3.</span> <span class="nav-text">3、分发函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、Objective-C根类"><span class="nav-number">8.5.4.</span> <span class="nav-text">4、Objective-C根类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、局部变量存储时长"><span class="nav-number">8.5.5.</span> <span class="nav-text">5、局部变量存储时长</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、关联对象行为"><span class="nav-number">8.5.6.</span> <span class="nav-text">6、关联对象行为</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YL</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'aliang9585githubio';
      var disqus_identifier = '2015/08/06/RunTime学习总结/';
      var disqus_title = 'RunTime学习总结';
      var disqus_url = 'http://aliang9585.github.io/2015/08/06/RunTime学习总结/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
